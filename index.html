<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bucket Jump ¬∑ Troll Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            margin: 0;
            padding: 0;
        }
        body {
            background: #fff0f5; /* Lavender Blush */
            background-image: radial-gradient(#e6e6fa 20%, transparent 20%),
                              radial-gradient(#e6e6fa 20%, transparent 20%);
            background-position: 0 0, 25px 25px;
            background-size: 50px 50px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
        }
        .game-wrapper {
            background: #ffffff;
            border: 8px solid #ffb7b2;
            padding: 1rem;
            border-radius: 30px;
            box-shadow: 0 20px 50px rgba(255, 183, 178, 0.4);
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            max-width: 1024px;
            aspect-ratio: 16 / 9;
            border-radius: 20px;
            background: linear-gradient(to bottom, #e0f7fa, #ffffff);
            cursor: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }
        .ui-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 16px;
            padding: 0 10px;
        }
        .stat-badge {
            background: #ffdac1;
            color: #ff6f61;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 1.5rem;
            box-shadow: 0 5px 0 #ffb7b2;
            text-transform: uppercase;
        }
        .btn-group {
            display: flex;
            gap: 15px;
        }
        button {
            background: #b5ead7;
            border: none;
            color: #555;
            font-family: 'Fredoka One', cursive;
            font-size: 1.2rem;
            padding: 10px 25px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 0 #84dcc6;
            transition: all 0.1s;
        }
        button:hover {
            transform: translateY(-2px);
            filter: brightness(1.05);
        }
        button:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #84dcc6;
        }
        button.secondary {
            background: #e2f0cb;
            box-shadow: 0 5px 0 #c7ceea;
        }
        
        /* Overlays */
        #loadingOverlay, #menuOverlay, #winOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        #menuOverlay {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
        }

        .title-text {
            font-size: 4rem;
            color: #ff9aa2;
            text-shadow: 3px 3px 0 #ffdac1;
            margin-bottom: 2rem;
            animation: float 3s ease-in-out infinite;
        }

        .play-btn {
            font-size: 2rem;
            padding: 15px 50px;
            background: #ff9aa2;
            color: white;
            box-shadow: 0 8px 0 #e88890;
        }

        #loadingOverlay {
            background: #fff;
            display: none;
            z-index: 20;
        }
        
        .loader-container {
            width: 300px;
            height: 20px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
        }
        .loader-bar {
            height: 100%;
            width: 0%;
            background: #ff9aa2;
            transition: width 0.1s;
            border-radius: 10px;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <canvas id="gameCanvas" width="1024" height="576"></canvas>

    <div class="ui-bar">
        <div class="stat-badge">
            ‚≠ê Level <span id="levelDisplay">1</span>
        </div>
        <div class="btn-group">
            <button class="secondary" id="restartBtn">‚Ü∫ Retry</button>
            <button class="secondary" id="soundToggle">üîä Sound</button>
            <button class="secondary" id="menuBtn">‚åÇ Home</button>
        </div>
        <div class="stat-badge" style="background: #e2f0cb; color: #6b8c42;">
            üíî Fails <span id="deathCounter">0</span>
        </div>
    </div>

    <div id="menuOverlay">
        <div class="title-text">BUCKET JUMP</div>
        <button class="play-btn" id="startBtn">PLAY GAME</button>
        <div style="margin-top: 20px; color: #888; font-size: 1rem;">Use Arrow Keys to Move & Jump</div>
    </div>

    <div id="loadingOverlay">
        <div style="font-size: 2rem; color: #ff9aa2;">Loading Traps...</div>
        <div class="loader-container">
            <div class="loader-bar" id="progressBar"></div>
        </div>
    </div>

    <div id="winOverlay" style="display: none; background: rgba(255,255,255,0.9);">
        <div class="title-text" style="color: #ffb7b2;">YOU SURVIVED!</div>
        <div style="font-size: 1.5rem; color: #555; margin-bottom: 30px;">The bucket is proud.</div>
        <button class="play-btn" id="backToMenuBtn">PLAY AGAIN</button>
    </div>
</div>

<script>
(function() {
    // ---------- SETUP ----------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const levelSpan = document.getElementById('levelDisplay');
    const deathSpan = document.getElementById('deathCounter');
    const menuOverlay = document.getElementById('menuOverlay');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const winOverlay = document.getElementById('winOverlay');
    const progressBar = document.getElementById('progressBar');
    
    // Buttons
    document.getElementById('startBtn').onclick = startLoadingSequence;
    document.getElementById('restartBtn').onclick = () => resetLevel();
    document.getElementById('menuBtn').onclick = () => {
        gameState = 'menu';
        menuOverlay.style.display = 'flex';
        winOverlay.style.display = 'none';
        sound.stopMusic();
    };
    document.getElementById('backToMenuBtn').onclick = () => {
         gameState = 'menu';
         menuOverlay.style.display = 'flex';
         winOverlay.style.display = 'none';
    };

    // ---------- SOUND ----------
    class SoundManager {
        constructor() {
            this.enabled = true;
            this.ctx = null;
        }
        init() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }
        playTone(freq, type, duration) {
            if (!this.enabled) return;
            this.init();
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }
        play(sfx) {
            if(!this.enabled) return;
            switch(sfx) {
                case 'jump': 
                    this.playTone(300, 'sine', 0.2); 
                    break;
                case 'land':
                    this.playTone(150, 'sine', 0.1);
                    break;
                case 'death':
                    this.playTone(100, 'sawtooth', 0.3); // Harsher sound for death
                    break;
                case 'win':
                    setTimeout(() => this.playTone(523.25, 'sine', 0.3), 0);
                    setTimeout(() => this.playTone(659.25, 'sine', 0.3), 100);
                    setTimeout(() => this.playTone(783.99, 'sine', 0.6), 200);
                    break;
            }
        }
        toggle() { this.enabled = !this.enabled; return this.enabled; }
        stopMusic() { }
    }

    const sound = new SoundManager();
    document.getElementById('soundToggle').onclick = function() {
        const on = sound.toggle();
        this.innerText = on ? 'üîä Sound' : 'üîá Mute';
        this.style.opacity = on ? 1 : 0.6;
    };

    // ---------- ENTITIES ----------
    
    class Player {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.w = 32; this.h = 32; 
            this.vx = 0; this.vy = 0;
            this.speed = 4; // REDUCED SPEED FOR CONTROL
            this.jumpPower = -10;
            this.grounded = false;
            this.alive = true;
            this.facingRight = true;
            this.scaleX = 1;
            this.scaleY = 1;
            this.angle = 0;
        }

        update(platforms, traps) {
            if (!this.alive) return;
            this.vy += 0.6;
            
            // Move X
            this.x += this.vx;
            this.collideX(platforms);

            // Move Y
            this.y += this.vy;
            this.collideY(platforms);

            // Physics Animation
            this.scaleX = lerp(this.scaleX, 1, 0.15);
            this.scaleY = lerp(this.scaleY, 1, 0.15);
            if (!this.grounded) this.angle = lerp(this.angle, this.vx * 0.05, 0.1);
            else this.angle = lerp(this.angle, 0, 0.2);

            // Trap Collision
            for (let t of traps) {
                if (t.active && this.collides(t)) this.die();
            }
            
            // Out of bounds
            if (this.y > 700 || this.x < -50 || this.x > 1100) this.die();
        }

        jump() {
            if (this.grounded) {
                this.vy = this.jumpPower;
                this.grounded = false;
                this.scaleX = 0.7; this.scaleY = 1.3;
                sound.play('jump');
                spawnDust(this.x + this.w/2, this.y + this.h);
            }
        }

        collideX(platforms) {
            for (let p of platforms) {
                if (!p.active) continue;
                if (this.collides(p)) {
                    if (this.vx > 0) { this.x = p.x - this.w; this.vx = 0; }
                    else if (this.vx < 0) { this.x = p.x + p.w; this.vx = 0; }
                }
            }
        }

        collideY(platforms) {
            this.grounded = false;
            for (let p of platforms) {
                if (!p.active) continue;
                if (this.collides(p)) {
                    if (this.vy > 0) {
                        this.y = p.y - this.h;
                        if(this.vy > 2) { 
                            this.scaleX = 1.3; this.scaleY = 0.7; 
                            sound.play('land');
                            spawnDust(this.x + this.w/2, this.y + this.h);
                        }
                        this.vy = 0;
                        this.grounded = true;
                    } else if (this.vy < 0) {
                        this.y = p.y + p.h;
                        this.vy = 0;
                    }
                }
            }
        }

        collides(o) {
            return this.x + 6 < o.x + o.w && this.x + this.w - 6 > o.x &&
                   this.y + 4 < o.y + o.h && this.y + this.h > o.y;
        }

        die() {
            if(this.alive) {
                this.alive = false;
                sound.play('death');
                spawnExplosion(this.x + this.w/2, this.y + this.h/2);
                lm.deaths++;
                deathSpan.innerText = lm.deaths;
                setTimeout(resetLevel, 600);
            }
        }

        draw(ctx) {
            const cx = this.x + this.w / 2;
            const cy = this.y + this.h; 
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(this.angle);
            ctx.scale(this.scaleX, this.scaleY);
            ctx.translate(-cx, -cy);

            // Bucket
            ctx.fillStyle = '#ff9aa2';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.w, this.y);
            ctx.lineTo(this.x + this.w - 4, this.y + this.h);
            ctx.lineTo(this.x + 4, this.y + this.h);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Rim
            ctx.beginPath();
            ctx.ellipse(cx, this.y, this.w/2, 4, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#ffb7b2';
            ctx.fill();
            ctx.stroke();

            // Handle
            ctx.beginPath();
            ctx.arc(cx, this.y, this.w/2, Math.PI, 0);
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Face
            const eyeOffset = this.facingRight ? 4 : -4;
            const eyeX = cx + eyeOffset;
            const eyeY = this.y + 16;
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(eyeX - 5, eyeY, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX + 5, eyeY, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = 'black';
            const pupilX = this.vx * 0.5;
            const pupilY = this.vy * 0.5;
            ctx.beginPath(); ctx.arc(eyeX - 5 + pupilX, eyeY + pupilY, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX + 5 + pupilX, eyeY + pupilY, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }
    }

    class Platform {
        constructor(x, y, w, h, moveType = null) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.initialY = y;
            this.initialX = x;
            this.active = true;
            this.moveType = moveType; 
            this.timer = Math.random() * 100;
        }
        update() {
            if (this.moveType === 'fall' && this.active) {
                if (player.collides(this)) {
                    this.y += 4; // Fast fall
                    if (this.y > 700) this.active = false;
                }
            } else if (this.moveType === 'lift') {
                this.timer += 0.03; // Slower lift
                this.y = this.initialY + Math.sin(this.timer) * 80;
            }
        }
        draw(ctx) {
            if (!this.active) return;
            // TROLL VISUAL: 'fall' platforms look EXACTLY like 'lift' or safe platforms
            ctx.fillStyle = '#b5ead7'; 
            
            drawRoundedRect(ctx, this.x, this.y, this.w, this.h, 8);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillRect(this.x + 5, this.y, this.w - 10, 6);

            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.arc(this.x + 10, this.y + this.h, 4, 0, Math.PI);
            ctx.arc(this.x + 30, this.y + this.h, 6, 0, Math.PI);
            ctx.fill();
        }
    }

    class Trap {
        constructor(x, y, w, h, isSpike = false, moving = false) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.isSpike = isSpike;
            this.moving = moving;
            this.initialY = y;
            this.time = Math.random() * 100;
            this.active = true;
        }
        update() {
            if (this.moving) {
                this.time += 0.05;
                this.y = this.initialY + Math.sin(this.time) * 60;
            }
        }
        draw(ctx) {
            if (!this.active) return;
            
            if (this.isSpike) {
                ctx.fillStyle = '#ff6f61';
                const spikes = Math.floor(this.w / 10);
                ctx.beginPath();
                for(let i=0; i<spikes; i++) {
                    // Triangle spikes
                    ctx.lineTo(this.x + (i*10), this.y); // top left
                    ctx.lineTo(this.x + (i*10) + 5, this.y + this.h); // point down
                    ctx.lineTo(this.x + (i*10) + 10, this.y); // top right
                }
                ctx.fill();
            } else {
                ctx.fillStyle = '#ff9aa2';
                drawRoundedRect(ctx, this.x, this.y, this.w, this.h, 4);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x + this.w/3, this.y + this.h/2 - 2, 3, 0, Math.PI*2);
                ctx.arc(this.x + this.w*2/3, this.y + this.h/2 - 2, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }

    // ---------- LEVEL MANAGER ----------
    class LevelManager {
        constructor() {
            this.currentLevel = 0;
            this.deaths = 0;
        }
        getLevelData(lvl) {
            const levels = [
                // LVL 1: Tutorial
                {
                    platforms: [
                        new Platform(100, 450, 200, 30),
                        new Platform(400, 380, 100, 20, 'fall'), 
                        new Platform(650, 400, 150, 30)
                    ],
                    traps: [new Trap(200, 440, 40, 10, true)], 
                    start: {x: 120, y: 350},
                    goal: {x: 700, y: 340}
                },
                // LVL 2: THE TROLL (Easier jumps, mean trap)
                {
                    platforms: [
                        new Platform(50, 500, 200, 30), // Start
                        new Platform(300, 420, 250, 20, 'lift'), // Huge lift
                        new Platform(650, 350, 250, 30) // End
                    ],
                    // TROLL: Ceiling spikes that block the jump when the lift is HIGH
                    traps: [
                        new Trap(400, 320, 100, 20, true) // Spike hanging in air
                    ],
                    start: {x: 70, y: 400},
                    goal: {x: 750, y: 290}
                },
                // LVL 3: TRUST ISSUES
                {
                    platforms: [
                        new Platform(50, 500, 150, 30),
                        new Platform(220, 450, 100, 20, 'fall'), // Looks safe
                        new Platform(350, 380, 100, 20, 'fall'), // Looks safe
                        new Platform(500, 300, 100, 20, 'fall'), // Looks safe
                        new Platform(700, 250, 150, 30)
                    ],
                    traps: [new Trap(720, 200, 30, 20, true)],
                    start: {x: 60, y: 400},
                    goal: {x: 780, y: 190}
                }
            ];
            return levels[lvl % levels.length];
        }
    }

    // ---------- GLOBAL STATE ----------
    const lm = new LevelManager();
    let player, platforms = [], traps = [], particles = [];
    let goal = {x: 0, y: 0, w: 40, h: 40, float: 0};
    let gameState = 'menu';
    let keys = { left: false, right: false, jump: false };

    // ---------- HELPER FUNCTIONS ----------
    function lerp(a, b, t) { return a + (b - a) * t; }
    
    function drawRoundedRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    function spawnDust(x, y) {
        for(let i=0; i<8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() * -2),
                size: Math.random() * 6 + 2,
                color: '#fff',
                life: 30
            });
        }
    }

    function spawnExplosion(x, y) {
        for(let i=0; i<20; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                size: Math.random() * 8 + 4,
                color: Math.random() > 0.5 ? '#ff9aa2' : '#ffdac1',
                life: 40
            });
        }
    }

    // ---------- GAME LOGIC ----------
    
    function startLoadingSequence() {
        menuOverlay.style.display = 'none';
        loadingOverlay.style.display = 'flex';
        gameState = 'loading';
        let progress = 0;
        
        const interval = setInterval(() => {
            progress += 2;
            progressBar.style.width = progress + '%';
            if (progress >= 100) {
                clearInterval(interval);
                loadingOverlay.style.display = 'none';
                gameState = 'playing';
                lm.currentLevel = 0;
                lm.deaths = 0;
                deathSpan.innerText = 0;
                resetLevel();
            }
        }, 20);
    }

    function resetLevel() {
        const data = lm.getLevelData(lm.currentLevel);
        platforms = data.platforms;
        traps = data.traps;
        player = new Player(data.start.x, data.start.y);
        goal.x = data.goal.x;
        goal.y = data.goal.y;
        levelSpan.innerText = lm.currentLevel + 1;
    }

    function update() {
        if (gameState !== 'playing') return;

        // Input
        if (keys.left) { player.vx = -player.speed; player.facingRight = false; }
        if (keys.right) { player.vx = player.speed; player.facingRight = true; }
        if (!keys.left && !keys.right) player.vx = 0;
        if (keys.jump) player.jump();

        // Updates
        platforms.forEach(p => p.update());
        traps.forEach(t => t.update());
        player.update(platforms, traps);

        // Goal Check
        goal.float += 0.1;
        if (player.alive && 
            player.x < goal.x + 30 && player.x + player.w > goal.x &&
            player.y < goal.y + 30 && player.y + player.h > goal.y) {
            
            sound.play('win');
            if (lm.currentLevel < 2) {
                lm.currentLevel++;
                resetLevel();
            } else {
                gameState = 'win';
                winOverlay.style.display = 'flex';
            }
        }

        // Particles
        particles.forEach((p, index) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            p.size *= 0.95;
            if(p.life <= 0) particles.splice(index, 1);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Background
        ctx.fillStyle = '#f0f8ff';
        ctx.beginPath();
        ctx.arc(100, 100, 60, 0, Math.PI*2);
        ctx.arc(800, 200, 80, 0, Math.PI*2);
        ctx.fill();

        if (gameState === 'playing' || gameState === 'win') {
            platforms.forEach(p => p.draw(ctx));
            traps.forEach(t => t.draw(ctx));

            // Goal
            const goalY = goal.y + Math.sin(goal.float) * 5;
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 20 + goal.x + 20,
                           -Math.sin((18 + i * 72) / 180 * Math.PI) * 20 + goalY + 20);
                ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 10 + goal.x + 20,
                           -Math.sin((54 + i * 72) / 180 * Math.PI) * 10 + goalY + 20);
            }
            ctx.fill();
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 20;
            ctx.stroke();
            ctx.shadowBlur = 0;

            if (player.alive) player.draw(ctx);

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }
        
        requestAnimationFrame(() => { update(); draw(); });
    }

    // ---------- INPUT ----------
    window.addEventListener('keydown', e => {
        if(e.key === 'ArrowLeft') keys.left = true;
        if(e.key === 'ArrowRight') keys.right = true;
        if(e.key === 'ArrowUp' || e.key === ' ') keys.jump = true;
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'ArrowLeft') keys.left = false;
        if(e.key === 'ArrowRight') keys.right = false;
        if(e.key === 'ArrowUp' || e.key === ' ') keys.jump = false;
    });

    draw();

})();
</script>
</body>
</html>
