<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jelly PoP - Blaster Fix</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        :root {
            --primary: #ff4081;
            --secondary: #00e5ff;
            --glass: rgba(255, 255, 255, 0.95);
            --tile-size: 45px;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at 50% 10%, #ffecb3 0%, #ffcc80 100%);
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
            z-index: 1;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
            transform: scale(1);
            z-index: 10;
        }

        .panel {
            background: var(--glass);
            padding: 20px;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            text-align: center;
            width: 90%;
            max-width: 400px;
            border: 4px solid #fff;
        }

        h1 {
            font-size: 3rem;
            color: #ff4081;
            margin: 0;
            text-shadow: 2px 2px 0px #fff, 4px 4px 0px rgba(0,0,0,0.1);
        }

        .btn {
            background: linear-gradient(to bottom, #ffeb3b, #fdd835);
            border: none;
            border-radius: 50px;
            padding: 12px 30px;
            font-size: 1.4rem;
            color: #d84315;
            font-family: inherit;
            cursor: pointer;
            margin: 8px;
            box-shadow: 0 5px 0 #f9a825, 0 10px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #f9a825; }
        .btn-pink { background: linear-gradient(to bottom, #ff80ab, #f50057); color: white; box-shadow: 0 5px 0 #c51162; }
        .btn-pink:active { box-shadow: 0 1px 0 #c51162; }

        /* --- Game Board --- */
        #board-wrapper {
            position: relative;
            background: rgba(255,255,255,0.5);
            border-radius: 15px;
            padding: 10px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
            margin: 10px 0;
        }

        .grid {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        .tile {
            position: absolute;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.2, 1.2);
            z-index: 10;
            filter: drop-shadow(0 3px 2px rgba(0,0,0,0.2));
            will-change: transform;
        }

        .tile.selected { 
            z-index: 20; 
            transform: scale(1.15) !important;
            filter: brightness(1.2) drop-shadow(0 5px 5px rgba(0,0,0,0.3));
        }
        
        /* BLASTER STYLES */
        .tile.blaster {
            z-index: 15;
        }
        .tile.blaster::after {
            content: '‚≠ê';
            position: absolute;
            font-size: 16px;
            top: -5px; right: -5px;
            animation: spin 2s linear infinite;
        }
        .tile.blaster::before {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            border: 3px solid #ffd700;
            box-sizing: border-box;
            animation: pulse-ring 1s infinite;
        }

        @keyframes pulse-ring { 0% { transform: scale(0.8); opacity: 1; } 100% { transform: scale(1.4); opacity: 0; } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes floatUp { 0% { transform: translateY(0); opacity:1; } 100% { transform: translateY(-50px); opacity:0; } }

        .floater {
            position: absolute;
            color: #fff;
            font-weight: 900;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s forwards;
            white-space: nowrap;
        }

        .header-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            background: #fff;
            padding: 8px 15px;
            border-radius: 15px;
            box-sizing: border-box;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .stat-box { display: flex; flex-direction: column; align-items: center; }
        .stat-label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        .stat-val { font-size: 1.2rem; color: #333; }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            padding: 5px;
        }
        .lvl-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 12px;
            background: #e0e0e0;
            font-family: inherit;
            font-size: 1.2rem;
            cursor: pointer;
        }
        .lvl-btn.unlocked { background: #00e5ff; color: #fff; box-shadow: 0 4px 0 #00b8d4; }
        .lvl-btn.unlocked:active { transform: translateY(2px); box-shadow: 0 0 0; }
    </style>
</head>
<body>

    <div id="screen-home" class="screen active">
        <div class="panel">
            <h1>Jelly Pop</h1>
            <p style="color:#666;">Blaster Edition</p>
            <button class="btn" onclick="game.openLevels()">Play</button>
        </div>
    </div>

    <div id="screen-levels" class="screen">
        <div class="panel">
            <h2>Select Level</h2>
            <div id="level-container" class="level-grid"></div>
            <button class="btn btn-pink" onclick="ui.nav('screen-home')" style="margin-top:15px;">Back</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="panel" style="padding:10px; width:95%; max-width:360px;">
            <div class="header-stats">
                <div class="stat-box"><span class="stat-label">Moves</span><span class="stat-val" id="ui-moves">0</span></div>
                <div class="stat-box"><span class="stat-label">Target</span><span class="stat-val" id="ui-target">0</span></div>
                <div class="stat-box"><span class="stat-label">Score</span><span class="stat-val" id="ui-score">0</span></div>
            </div>

            <div style="width:100%; height:8px; background:#eee; border-radius:4px; margin:10px 0; overflow:hidden;">
                <div id="progress-bar" style="width:0%; height:100%; background:#00e5ff; transition:width 0.5s;"></div>
            </div>

            <div id="board-wrapper">
                <div id="grid" class="grid"></div>
            </div>

            <button class="btn btn-pink" onclick="game.quit()" style="font-size:1rem; padding:8px 20px;">Exit Level</button>
        </div>
    </div>

    <div id="screen-result" class="screen" style="background: rgba(0,0,0,0.8);">
        <div class="panel">
            <h1 id="res-title">Win!</h1>
            <div id="res-msg" style="margin:20px 0; font-size:1.2rem;"></div>
            <button class="btn" onclick="game.openLevels()">Levels</button>
            <button class="btn btn-pink" onclick="game.retry()">Retry</button>
        </div>
    </div>

    <script>
        // --- CONFIG & STATE ---
        const CFG = { w: 8, h: 8, size: 40, colors: ['üî¥','üü†','üü°','üü¢','üîµ','üü£'] };
        const STATE = {
            grid: [],     // Internal numbers
            domGrid: [],  // DOM Elements
            score: 0,
            moves: 0,
            target: 0,
            level: 1,
            maxLevel: 1,
            selected: null,
            locked: false,
            blasters: []  // Tracks blaster positions
        };

        const AUDIO = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            play(type) {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                if(type === 'swap') {
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(500, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'match') {
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(900, now + 0.15);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                } else if (type === 'blaster') {
                    // Blaster sound
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                }
            }
        };

        const ui = {
            nav(id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                document.getElementById(id).classList.add('active');
            },
            update() {
                document.getElementById('ui-score').innerText = STATE.score;
                document.getElementById('ui-moves').innerText = STATE.moves;
                document.getElementById('ui-target').innerText = STATE.target;
                const pct = Math.min(100, (STATE.score / STATE.target) * 100);
                document.getElementById('progress-bar').style.width = pct + '%';
            }
        };

        const game = {
            openLevels() {
                const c = document.getElementById('level-container');
                c.innerHTML = '';
                for(let i=1; i<=20; i++) {
                    const btn = document.createElement('button');
                    btn.className = `lvl-btn ${i <= STATE.maxLevel ? 'unlocked' : ''}`;
                    btn.innerText = i;
                    if(i <= STATE.maxLevel) btn.onclick = () => this.start(i);
                    c.appendChild(btn);
                }
                ui.nav('screen-levels');
            },
            
            start(lvl) {
                STATE.level = lvl;
                STATE.moves = 15 + Math.floor(lvl * 1.5);
                STATE.target = 500 + (lvl * 200);
                STATE.score = 0;
                STATE.locked = false;
                STATE.selected = null;
                STATE.blasters = []; // Reset blasters
                
                this.buildGrid();
                ui.update();
                ui.nav('screen-game');
            },

            buildGrid() {
                const gridEl = document.getElementById('grid');
                gridEl.innerHTML = '';
                STATE.grid = [];
                STATE.domGrid = [];

                for(let r=0; r<CFG.h; r++) {
                    let row = [], domRow = [];
                    for(let c=0; c<CFG.w; c++) {
                        let type;
                        do { type = Math.floor(Math.random() * CFG.colors.length); }
                        while (
                            (r>=2 && STATE.grid[r-1][c]===type && STATE.grid[r-2][c]===type) ||
                            (c>=2 && row[c-1]===type && row[c-2]===type)
                        );
                        row.push(type);
                        const el = this.createTile(r, c, type);
                        gridEl.appendChild(el);
                        domRow.push(el);
                    }
                    STATE.grid.push(row);
                    STATE.domGrid.push(domRow);
                }
                STATE.blasters = Array(CFG.h).fill().map(() => Array(CFG.w).fill(false));
            },

            createTile(r, c, type) {
                const el = document.createElement('div');
                el.className = 'tile';
                el.innerText = CFG.colors[type];
                el.style.transform = `translate(${c * CFG.size}px, ${r * CFG.size}px)`;
                el.dataset.r = r;
                el.dataset.c = c;
                
                // Input Handling
                const handleStart = (e) => {
                    if(STATE.locked) return;
                    e.preventDefault();
                    const t = e.touches ? e.touches[0] : e;
                    this.handleInput(parseInt(el.dataset.r), parseInt(el.dataset.c));
                };
                
                el.onmousedown = handleStart;
                el.ontouchstart = handleStart;
                return el;
            },

            handleInput(r, c) {
                if(!STATE.selected) {
                    STATE.selected = {r, c};
                    STATE.domGrid[r][c].classList.add('selected');
                    AUDIO.play('swap');
                } else {
                    const prev = STATE.selected;
                    STATE.domGrid[prev.r][prev.c].classList.remove('selected');
                    STATE.selected = null;

                    const dr = Math.abs(prev.r - r);
                    const dc = Math.abs(prev.c - c);
                    
                    if(dr + dc === 1) {
                        this.attemptSwap(prev, {r, c});
                    } else if (prev.r !== r || prev.c !== c) {
                        // If clicked far away, select new
                        STATE.selected = {r, c};
                        STATE.domGrid[r][c].classList.add('selected');
                    }
                }
            },

            async attemptSwap(p1, p2) {
                STATE.locked = true;
                await this.animSwap(p1, p2);
                
                // Logical Swap
                [STATE.grid[p1.r][p1.c], STATE.grid[p2.r][p2.c]] = [STATE.grid[p2.r][p2.c], STATE.grid[p1.r][p1.c]];
                [STATE.blasters[p1.r][p1.c], STATE.blasters[p2.r][p2.c]] = [STATE.blasters[p2.r][p2.c], STATE.blasters[p1.r][p1.c]];
                this.updateDomIds(p1, p2);

                const matches = this.findMatches();
                if(matches.length > 0) {
                    STATE.moves--;
                    ui.update();
                    await this.processMatches(matches);
                } else {
                    // Undo
                    await this.animSwap(p1, p2);
                    [STATE.grid[p1.r][p1.c], STATE.grid[p2.r][p2.c]] = [STATE.grid[p2.r][p2.c], STATE.grid[p1.r][p1.c]];
                    [STATE.blasters[p1.r][p1.c], STATE.blasters[p2.r][p2.c]] = [STATE.blasters[p2.r][p2.c], STATE.blasters[p1.r][p1.c]];
                    this.updateDomIds(p1, p2);
                    STATE.locked = false;
                }
            },

            async animSwap(p1, p2) {
                const el1 = STATE.domGrid[p1.r][p1.c];
                const el2 = STATE.domGrid[p2.r][p2.c];
                
                el1.style.transform = `translate(${p2.c * CFG.size}px, ${p2.r * CFG.size}px)`;
                el2.style.transform = `translate(${p1.c * CFG.size}px, ${p1.r * CFG.size}px)`;
                
                // Swap DOM refs
                STATE.domGrid[p1.r][p1.c] = el2;
                STATE.domGrid[p2.r][p2.c] = el1;

                return new Promise(r => setTimeout(r, 250));
            },

            updateDomIds(p1, p2) {
                const el1 = STATE.domGrid[p1.r][p1.c];
                const el2 = STATE.domGrid[p2.r][p2.c];
                el1.dataset.r = p1.r; el1.dataset.c = p1.c;
                el2.dataset.r = p2.r; el2.dataset.c = p2.c;
            },

            // --- CORE LOGIC: MATCHING ---
            findMatches() {
                const groups = [];
                const visitedH = new Set();
                const visitedV = new Set();

                // Horizontal
                for(let r=0; r<CFG.h; r++) {
                    for(let c=0; c<CFG.w-2; c++) {
                        let type = STATE.grid[r][c];
                        if(type === -1) continue;
                        let match = [{r,c}];
                        while(c+match.length < CFG.w && STATE.grid[r][c+match.length] === type) {
                            match.push({r, c: c+match.length});
                        }
                        if(match.length >= 3) {
                            groups.push(match);
                            c += match.length - 1;
                        }
                    }
                }
                
                // Vertical
                for(let c=0; c<CFG.w; c++) {
                    for(let r=0; r<CFG.h-2; r++) {
                        let type = STATE.grid[r][c];
                        if(type === -1) continue;
                        let match = [{r,c}];
                        while(r+match.length < CFG.h && STATE.grid[r+match.length][c] === type) {
                            match.push({r: r+match.length, c});
                        }
                        if(match.length >= 3) {
                            groups.push(match);
                            r += match.length - 1;
                        }
                    }
                }
                return groups;
            },

            async processMatches(groups) {
                const uniqueTilesToRemove = new Set();
                const blastersToCreate = [];

                for(let group of groups) {
                    // FEATURE: If match is 4+, mark center for Blaster creation
                    if(group.length >= 4) {
                        const center = group[Math.floor(group.length/2)];
                        blastersToCreate.push({r: center.r, c: center.c});
                        // Remove center from destruction list if it was added by another crossing match
                        uniqueTilesToRemove.delete(`${center.r},${center.c}`);
                    }
                    
                    for(let tile of group) {
                        // Don't destroy if it's becoming a blaster
                        const isBecomingBlaster = blastersToCreate.some(b => b.r === tile.r && b.c === tile.c);
                        if(!isBecomingBlaster) {
                            uniqueTilesToRemove.add(`${tile.r},${tile.c}`);
                        }
                    }
                }

                // Execute Logic
                let scoreGain = uniqueTilesToRemove.size * 10;
                let blasterTriggered = false;

                // 1. Create Blasters
                for(let b of blastersToCreate) {
                    STATE.blasters[b.r][b.c] = true;
                    const el = STATE.domGrid[b.r][b.c];
                    el.classList.add('blaster');
                    this.floatText(b.r, b.c, "BLASTER!");
                    AUDIO.play('blaster');
                }

                // 2. Remove Tiles
                uniqueTilesToRemove.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    
                    // CHECK: Was this a blaster?
                    if(STATE.blasters[r][c]) {
                        scoreGain += 150; // BONUS
                        this.floatText(r, c, "+150 BLAST!");
                        AUDIO.play('blaster');
                        blasterTriggered = true;
                        STATE.blasters[r][c] = false; // Consume it
                    }

                    STATE.grid[r][c] = -1;
                    const el = STATE.domGrid[r][c];
                    el.style.transform += " scale(0)";
                    el.style.opacity = 0;
                });

                if(!blasterTriggered && uniqueTilesToRemove.size > 0) AUDIO.play('match');
                
                STATE.score += scoreGain;
                ui.update();

                await new Promise(r => setTimeout(r, 300));

                // 3. Clean DOM
                uniqueTilesToRemove.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    if(STATE.domGrid[r][c]) {
                        STATE.domGrid[r][c].remove();
                        STATE.domGrid[r][c] = null;
                    }
                });

                await this.applyGravity();
            },

            async applyGravity() {
                let moved = false;

                // Column by column
                for(let c=0; c<CFG.w; c++) {
                    let writeRow = CFG.h - 1;
                    
                    // 1. Shift existing items down
                    for(let readRow = CFG.h - 1; readRow >= 0; readRow--) {
                        if(STATE.grid[readRow][c] !== -1) {
                            if(writeRow !== readRow) {
                                // Move Logic
                                STATE.grid[writeRow][c] = STATE.grid[readRow][c];
                                STATE.grid[readRow][c] = -1;
                                STATE.blasters[writeRow][c] = STATE.blasters[readRow][c]; // Move blaster status
                                STATE.blasters[readRow][c] = false;

                                // Move Visuals
                                const el = STATE.domGrid[readRow][c];
                                STATE.domGrid[writeRow][c] = el;
                                STATE.domGrid[readRow][c] = null;
                                
                                if(el) {
                                    el.dataset.r = writeRow;
                                    el.style.transform = `translate(${c*CFG.size}px, ${writeRow*CFG.size}px)`;
                                }
                                moved = true;
                            }
                            writeRow--;
                        }
                    }

                    // 2. Fill top with new
                    while(writeRow >= 0) {
                        const type = Math.floor(Math.random() * CFG.colors.length);
                        STATE.grid[writeRow][c] = type;
                        STATE.blasters[writeRow][c] = false;
                        
                        const el = this.createTile(writeRow, c, type);
                        el.style.transform = `translate(${c*CFG.size}px, -${CFG.size}px)`; // Start above
                        document.getElementById('grid').appendChild(el);
                        STATE.domGrid[writeRow][c] = el;

                        // Animate drop
                        // Force reflow
                        void el.offsetWidth; 
                        el.style.transform = `translate(${c*CFG.size}px, ${writeRow*CFG.size}px)`;
                        
                        writeRow--;
                        moved = true;
                    }
                }

                if(moved) {
                    await new Promise(r => setTimeout(r, 400));
                    const newMatches = this.findMatches();
                    if(newMatches.length > 0) {
                        await this.processMatches(newMatches);
                    } else {
                        STATE.locked = false;
                        this.checkWinLoss();
                    }
                } else {
                    STATE.locked = false;
                    this.checkWinLoss();
                }
            },

            floatText(r, c, txt) {
                const div = document.createElement('div');
                div.className = 'floater';
                div.innerText = txt;
                div.style.left = (c*CFG.size) + 'px';
                div.style.top = (r*CFG.size) + 'px';
                document.getElementById('grid').appendChild(div);
                setTimeout(() => div.remove(), 1000);
            },

            checkWinLoss() {
                if(STATE.score >= STATE.target) {
                    if(STATE.level === STATE.maxLevel) STATE.maxLevel++;
                    this.endGame(true);
                } else if (STATE.moves <= 0) {
                    this.endGame(false);
                }
            },

            endGame(win) {
                document.getElementById('res-title').innerText = win ? "Level Complete!" : "Out of Moves";
                document.getElementById('res-msg').innerText = win ? `Score: ${STATE.score}` : "Try Again?";
                document.getElementById('res-title').style.color = win ? "#00e676" : "#ff1744";
                ui.nav('screen-result');
            },
            
            quit() { ui.nav('screen-home'); },
            retry() { this.start(STATE.level); }
        };

        // Init
        ui.nav('screen-home');

    </script>
</body>
</html>
