<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sugar Rush: Ultimate</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');

        :root {
            --primary: #ff4081;
            --secondary: #00e5ff;
            --glass: rgba(255, 255, 255, 0.9);
            --tile-size: 45px;
            --gap: 4px;
        }

        body {
            margin: 0;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            background-image: radial-gradient(circle at 10% 20%, rgb(255, 197, 218) 0%, rgb(255, 120, 189) 90.1%);
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* --- Screens & UI --- */
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            z-index: 1;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
            transform: scale(1);
            z-index: 10;
        }

        .panel {
            background: var(--glass);
            padding: 20px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2), inset 0 0 0 5px rgba(255,255,255,0.5);
            text-align: center;
            width: 90%;
            max-width: 400px;
            backdrop-filter: blur(10px);
            animation: float 4s ease-in-out infinite;
        }

        h1 {
            font-size: 3rem;
            background: -webkit-linear-gradient(#ff00cc, #333399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
            filter: drop-shadow(2px 2px 0px #fff);
        }

        .btn {
            background: linear-gradient(to bottom, #ffeb3b, #ffc107);
            border: none;
            border-radius: 50px;
            padding: 15px 40px;
            font-size: 1.5rem;
            color: #d32f2f;
            font-family: inherit;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 6px 0 #c69403, 0 10px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #c69403; }
        .btn-pink { background: linear-gradient(to bottom, #ff80ab, #f50057); color: white; box-shadow: 0 6px 0 #ad003d; }
        .btn-pink:active { box-shadow: 0 2px 0 #ad003d; }
        .btn-icon { padding: 10px; width: 60px; height: 60px; border-radius: 50%; font-size: 1.8rem; }

        /* --- Game Board --- */
        .header-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
            background: white;
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .stat div:first-child { font-size: 0.8rem; color: #888; }
        .stat div:last-child { font-size: 1.4rem; color: #333; }

        #board-container {
            position: relative;
            background: rgba(0,0,0,0.1);
            border-radius: 15px;
            padding: 10px;
            box-shadow: inset 0 4px 10px rgba(0,0,0,0.1);
        }

        .grid {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        .tile {
            position: absolute;
            width: 40px;
            height: 40px;
            left: 0; top: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
            touch-action: none; 
        }

        .tile.selected { z-index: 20; }
        .tile.selected::after {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            animation: pulse 0.8s infinite;
        }
        .tile.hint { animation: shake 2s infinite; filter: brightness(1.3); }

        /* Particles */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: pop 0.6s ease-out forwards;
        }

        /* --- Shop Items --- */
        .shop-item {
            display: flex;
            align-items: center;
            background: #fff;
            margin: 10px 0;
            padding: 15px;
            border-radius: 15px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .shop-item:hover { border-color: gold; transform: scale(1.02); }
        .shop-price { background: #ffd700; color: #8a6e02; padding: 5px 10px; border-radius: 10px; font-size: 0.9rem; }

        /* --- Animations --- */
        @keyframes pulse { 0% { transform: scale(0.9); } 50% { transform: scale(1.1); } 100% { transform: scale(0.9); } }
        @keyframes pop { 0% { transform: translate(0,0) scale(1); opacity: 1; } 100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        
        .floater {
            position: absolute;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            z-index: 100;
        }
        @keyframes floatUp { to { transform: translateY(-50px); opacity: 0; } }

        .mode-active { cursor: crosshair !important; border: 4px solid red; }

    </style>
</head>
<body>

    <div style="position:absolute; top:10px; right:10px; z-index:100;">
        <button id="btn-sound" class="btn btn-icon" style="width:40px; height:40px; font-size:1.2rem; padding:0;" onclick="audioSys.toggle()">üîá</button>
    </div>

    <div id="screen-home" class="screen active">
        <div class="panel">
            <h1>Jelly<br>Pop</h1>
            <p>Ultimate Edition</p>
            <button class="btn" onclick="game.init()">PLAY</button>
            <button class="btn btn-pink" onclick="ui.nav('screen-shop')">SHOP</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="panel" style="width: 100%; max-width: 380px; padding: 10px; background: rgba(255,255,255,0.7);">
            <div class="header-stats">
                <div class="stat"><div>MOVES</div><div id="ui-moves">20</div></div>
                <div class="stat"><div>TARGET</div><div id="ui-target">1000</div></div>
                <div class="stat"><div>SCORE</div><div id="ui-score">0</div></div>
            </div>
            
            <div style="width:100%; height:10px; background:#ddd; border-radius:5px; margin-bottom:10px; overflow:hidden;">
                <div id="score-bar" style="height:100%; width:0%; background:#00e5ff; transition:width 0.5s;"></div>
            </div>

            <div id="board-container">
                <div id="grid" class="grid"></div>
            </div>

            <div style="margin-top:15px; display:flex; justify-content:center; gap:10px;">
                <button class="btn btn-pink btn-icon" id="btn-hammer" onclick="powerups.activate('hammer')">üî®</button>
                <button class="btn btn-pink btn-icon" id="btn-bomb" onclick="powerups.activate('bomb')">üí£</button>
                <button class="btn btn-pink btn-icon" id="btn-shuffle" onclick="powerups.activate('shuffle')">üîÑ</button>
            </div>
            <button style="margin-top:5px; background:transparent; border:none; color:#666;" onclick="game.gameOver(false)">Give Up</button>
        </div>
    </div>

    <div id="screen-shop" class="screen">
        <div class="panel">
            <h2>Market</h2>
            <div style="margin-bottom:10px;">Coins: <span id="shop-coins" style="color:#e6b800; font-size:1.5rem;">0</span></div>
            
            <div class="shop-item" onclick="market.buy('hammer')">
                <div style="font-size:2rem; margin-right:10px;">üî®</div>
                <div style="text-align:left; flex:1">
                    <div>Smash</div>
                    <div style="font-size:0.7rem; color:#888;">Destroy 1 candy</div>
                </div>
                <div class="shop-price">100</div>
            </div>

            <div class="shop-item" onclick="market.buy('bomb')">
                <div style="font-size:2rem; margin-right:10px;">üí£</div>
                <div style="text-align:left; flex:1">
                    <div>Bomb</div>
                    <div style="font-size:0.7rem; color:#888;">Destroy 3x3 area</div>
                </div>
                <div class="shop-price">250</div>
            </div>

            <div class="shop-item" onclick="market.buy('shuffle')">
                <div style="font-size:2rem; margin-right:10px;">üîÑ</div>
                <div style="text-align:left; flex:1">
                    <div>Shuffle</div>
                    <div style="font-size:0.7rem; color:#888;">Mix the board</div>
                </div>
                <div class="shop-price">150</div>
            </div>

            <div id="shop-msg" style="height:20px; color:red; font-size:0.8rem;"></div>
            <button class="btn" onclick="ui.nav('screen-home')">Back</button>
        </div>
    </div>

    <div id="screen-result" class="screen" style="z-index:20; background:rgba(0,0,0,0.8);">
        <div class="panel">
            <h1 id="res-title">Won!</h1>
            <div id="res-stars" style="font-size:3rem;">‚≠ê‚≠ê‚≠ê</div>
            <p id="res-msg">Score: 5000</p>
            <button class="btn" onclick="ui.nav('screen-home')">Continue</button>
        </div>
    </div>

    <script>
        // --- AUDIO ENGINE (Synthesizer) ---
        const audioSys = {
            ctx: null,
            bgmOsc: [],
            isMuted: true,
            isPlaying: false,

            init() {
                if(!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },

            toggle() {
                this.init();
                this.isMuted = !this.isMuted;
                document.getElementById('btn-sound').innerText = this.isMuted ? 'üîá' : 'üîä';
                if(!this.isMuted && !this.isPlaying) this.playMusic();
                if(this.isMuted) this.stopMusic();
            },

            playNote(freq, type, dur, vol=0.1) {
                if(this.isMuted) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + dur);
            },

            sfx(name) {
                if(this.isMuted) return;
                switch(name) {
                    case 'swap': this.playNote(400, 'sine', 0.1); break;
                    case 'match': 
                        this.playNote(600, 'triangle', 0.1); 
                        setTimeout(()=>this.playNote(800, 'triangle', 0.1), 100);
                        break;
                    case 'bad': this.playNote(150, 'sawtooth', 0.3); break;
                    case 'win': 
                        [0, 0.2, 0.4].forEach((t, i) => setTimeout(() => this.playNote(500 + i*200, 'square', 0.3), t*1000));
                        break;
                }
            },

            playMusic() {
                if(this.isMuted || this.isPlaying) return;
                this.isPlaying = true;
                let note = 0;
                const melody = [392, 523, 659, 783, 659, 523]; 
                const interval = setInterval(() => {
                    if(this.isMuted) { clearInterval(interval); this.isPlaying = false; return; }
                    this.playNote(melody[note % melody.length], 'sine', 0.5, 0.05);
                    note++;
                }, 400);
            },
            stopMusic() {
                this.isPlaying = false;
            }
        };

        // --- GAME LOGIC ---
        const cfg = { w: 8, h: 8, size: 40 };
        const emojis = ['üçá', 'üçä', 'ü••', 'üç≠', 'üßÅ', 'üç©']; 
        
        let grid = []; 
        let domGrid = []; 
        let state = {
            selected: null,
            locked: false,
            score: 0,
            moves: 20,
            target: 1000,
            inventory: { hammer: 1, bomb: 0, shuffle: 1 },
            coins: 100,
            activeTool: null
        };
        
        let hintTimer = null;

        const ui = {
            nav(id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                if(id === 'screen-shop') this.updateShop();
            },
            updateStats() {
                document.getElementById('ui-score').innerText = state.score;
                document.getElementById('ui-moves').innerText = state.moves;
                const pct = Math.min(100, (state.score / state.target) * 100);
                document.getElementById('score-bar').style.width = pct + '%';
            },
            updateShop() {
                document.getElementById('shop-coins').innerText = state.coins;
                document.getElementById('btn-hammer').innerHTML = `üî® <span style="font-size:0.6rem">${state.inventory.hammer}</span>`;
                document.getElementById('btn-bomb').innerHTML = `üí£ <span style="font-size:0.6rem">${state.inventory.bomb}</span>`;
                document.getElementById('btn-shuffle').innerHTML = `üîÑ <span style="font-size:0.6rem">${state.inventory.shuffle}</span>`;
            }
        };

        const game = {
            init() {
                state.score = 0;
                state.moves = 20;
                state.locked = false;
                state.activeTool = null;
                audioSys.init();
                audioSys.playMusic();
                
                ui.nav('screen-game');
                this.buildGrid();
                ui.updateStats();
                ui.updateShop();
                this.resetHint();
            },

            buildGrid() {
                const con = document.getElementById('grid');
                con.innerHTML = '';
                grid = [];
                domGrid = [];

                for(let r=0; r<cfg.h; r++) {
                    let row = [], dRow = [];
                    for(let c=0; c<cfg.w; c++) {
                        let type;
                        do {
                            type = Math.floor(Math.random() * emojis.length);
                        } while(
                            (r>=2 && grid[r-1][c]===type && grid[r-2][c]===type) ||
                            (c>=2 && row[c-1]===type && row[c-2]===type)
                        );
                        
                        row.push(type);
                        
                        const el = document.createElement('div');
                        el.className = 'tile';
                        el.style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px)`;
                        el.innerText = emojis[type];
                        el.dataset.r = r;
                        el.dataset.c = c;
                        
                        this.attachInput(el, r, c);
                        
                        con.appendChild(el);
                        dRow.push(el);
                    }
                    grid.push(row);
                    domGrid.push(dRow);
                }
            },

            attachInput(el, r, c) {
                let startX, startY;

                const start = (e) => {
                    if(state.locked) return;
                    if(state.activeTool) {
                        powerups.use(r, c);
                        return;
                    }

                    const t = e.touches ? e.touches[0] : e;
                    startX = t.clientX;
                    startY = t.clientY;
                    
                    if(!state.selected) {
                        this.select(r, c);
                    } else if (state.selected.r === r && state.selected.c === c) {
                        this.deselect();
                    } else {
                        const dr = Math.abs(state.selected.r - r);
                        const dc = Math.abs(state.selected.c - c);
                        if(dr + dc === 1) {
                            // Fixed: Clear selection state immediately before attempting swap
                            const oldSel = state.selected;
                            this.deselect();
                            this.attemptSwap(oldSel, {r, c});
                        } else {
                            this.select(r, c); 
                        }
                    }
                };

                const move = (e) => {
                    if(!state.selected || state.locked) return;
                    if(state.selected.r !== r || state.selected.c !== c) return; 

                    const t = e.touches ? e.touches[0] : e;
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;
                    
                    if(Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                        let targetR = r;
                        let targetC = c;
                        if(Math.abs(dx) > Math.abs(dy)) {
                            targetC += dx > 0 ? 1 : -1;
                        } else {
                            targetR += dy > 0 ? 1 : -1;
                        }
                        
                        if(targetR >=0 && targetR < cfg.h && targetC >= 0 && targetC < cfg.w) {
                            this.attemptSwap({r,c}, {r:targetR, c:targetC});
                            this.deselect(); 
                        }
                    }
                };

                el.addEventListener('mousedown', start);
                el.addEventListener('touchstart', start);
                el.addEventListener('mousemove', move); 
                el.addEventListener('touchmove', move);
            },

            select(r, c) {
                this.deselect();
                state.selected = {r, c};
                domGrid[r][c].classList.add('selected');
                audioSys.sfx('swap');
            },
            deselect() {
                if(state.selected) {
                    domGrid[state.selected.r][state.selected.c].classList.remove('selected');
                    state.selected = null;
                }
            },

            resetHint() {
                clearTimeout(hintTimer);
                document.querySelectorAll('.hint').forEach(e => e.classList.remove('hint'));
                hintTimer = setTimeout(() => this.showHint(), 5000);
            },

            showHint() {
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(c<cfg.w-1) {
                            this.swapData(r, c, r, c+1);
                            if(this.findMatches().length > 0) {
                                domGrid[r][c].classList.add('hint');
                                domGrid[r][c+1].classList.add('hint');
                                this.swapData(r, c, r, c+1); 
                                return;
                            }
                            this.swapData(r, c, r, c+1); 
                        }
                        if(r<cfg.h-1) {
                            this.swapData(r, c, r+1, c);
                            if(this.findMatches().length > 0) {
                                domGrid[r][c].classList.add('hint');
                                domGrid[r+1][c].classList.add('hint');
                                this.swapData(r, c, r+1, c);
                                return;
                            }
                            this.swapData(r, c, r+1, c);
                        }
                    }
                }
            },

            async attemptSwap(p1, p2) {
                state.locked = true;
                this.resetHint();
                
                await this.animSwap(p1, p2);
                this.swapData(p1.r, p1.c, p2.r, p2.c);
                
                const matches = this.findMatches();
                
                if(matches.length > 0) {
                    state.moves--;
                    ui.updateStats();
                    await this.processMatches(matches);
                } else {
                    audioSys.sfx('bad');
                    this.swapData(p1.r, p1.c, p2.r, p2.c); // revert data logic
                    
                    // Fixed: Revert visual explicitly directly back to original spots
                    const t1 = domGrid[p1.r][p1.c];
                    const t2 = domGrid[p2.r][p2.c];
                    t1.style.transform = `translate(${p1.c*cfg.size}px, ${p1.r*cfg.size}px)`;
                    t2.style.transform = `translate(${p2.c*cfg.size}px, ${p2.r*cfg.size}px)`;
                    
                    await this.wait(250);
                    state.locked = false;
                }
            },

            swapData(r1, c1, r2, c2) {
                let temp = grid[r1][c1];
                grid[r1][c1] = grid[r2][c2];
                grid[r2][c2] = temp;
                
                let tEl = domGrid[r1][c1];
                domGrid[r1][c1] = domGrid[r2][c2];
                domGrid[r2][c2] = tEl;
                
                if(domGrid[r1][c1]) { domGrid[r1][c1].dataset.r = r1; domGrid[r1][c1].dataset.c = c1; }
                if(domGrid[r2][c2]) { domGrid[r2][c2].dataset.r = r2; domGrid[r2][c2].dataset.c = c2; }
            },

            animSwap(p1, p2) {
                return new Promise(resolve => {
                    const t1 = domGrid[p1.r][p1.c]; 
                    const t2 = domGrid[p2.r][p2.c];
                    
                    t1.style.transform = `translate(${p2.c*cfg.size}px, ${p2.r*cfg.size}px)`;
                    t2.style.transform = `translate(${p1.c*cfg.size}px, ${p1.r*cfg.size}px)`;
                    
                    setTimeout(() => resolve(), 250);
                });
            },

            findMatches() {
                let matched = new Set();
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w-2; c++) {
                        let t = grid[r][c];
                        if(t === -1) continue;
                        if(grid[r][c+1] === t && grid[r][c+2] === t) {
                            matched.add(`${r},${c}`); matched.add(`${r},${c+1}`); matched.add(`${r},${c+2}`);
                        }
                    }
                }
                for(let c=0; c<cfg.w; c++) {
                    for(let r=0; r<cfg.h-2; r++) {
                        let t = grid[r][c];
                        if(t === -1) continue;
                        if(grid[r+1][c] === t && grid[r+2][c] === t) {
                            matched.add(`${r},${c}`); matched.add(`${r+1},${c}`); matched.add(`${r+2},${c}`);
                        }
                    }
                }
                return Array.from(matched).map(s => {
                    const [r, c] = s.split(',').map(Number);
                    return {r, c};
                });
            },

            async processMatches(matches) {
                this.deselect();
                audioSys.sfx('match');
                
                const baseScore = matches.length * 10;
                const bonus = matches.length > 3 ? (matches.length-3)*10 : 0;
                state.score += baseScore + bonus;
                ui.updateStats();

                const center = matches[Math.floor(matches.length/2)];
                this.floatText(center.r, center.c, `+${baseScore+bonus}`);

                for(let m of matches) {
                    const el = domGrid[m.r][m.c];
                    this.createParticles(m.r, m.c, el.innerText);
                    el.style.transform = `${el.style.transform} scale(0)`;
                    grid[m.r][m.c] = -1; 
                }

                await this.wait(300);
                await this.applyGravity();
            },

            async applyGravity() {
                let moved = false;
                
                for(let c=0; c<cfg.w; c++) {
                    let emptyCount = 0;
                    for(let r=cfg.h-1; r>=0; r--) {
                        if(grid[r][c] === -1) {
                            emptyCount++;
                        } else if (emptyCount > 0) {
                            this.swapData(r, c, r+emptyCount, c);
                            const el = domGrid[r+emptyCount][c];
                            // Fixed: Remove invalid CSS transition 'bounce' to let the class transition take over smoothly
                            el.style.transition = ""; 
                            el.style.transform = `translate(${c*cfg.size}px, ${(r+emptyCount)*cfg.size}px)`;
                            moved = true;
                        }
                    }
                    
                    for(let r=0; r<emptyCount; r++) {
                        const type = Math.floor(Math.random() * emojis.length);
                        grid[r][c] = type;
                        
                        let el = domGrid[r][c]; 
                        el.innerText = emojis[type];
                        el.style.transition = 'none';
                        el.style.transform = `translate(${c*cfg.size}px, -50px)`;
                        
                        void el.offsetWidth;
                        
                        // Fixed: Restores smooth CSS transition
                        el.style.transition = ""; 
                        el.style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px)`;
                        el.style.opacity = 1;
                        el.style.zIndex = 10;
                        moved = true;
                    }
                }

                if(moved) {
                    await this.wait(400);
                    const newMatches = this.findMatches();
                    if(newMatches.length > 0) {
                        await this.processMatches(newMatches);
                    } else {
                        state.locked = false;
                        this.resetHint();
                        this.checkWin();
                    }
                } else {
                    state.locked = false;
                    this.resetHint();
                }
            },

            createParticles(r, c, char) {
                const x = c * cfg.size + 20;
                const y = r * cfg.size + 20;
                
                for(let i=0; i<6; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.innerText = char; 
                    p.style.fontSize = '12px';
                    p.style.left = x + 'px';
                    p.style.top = y + 'px';
                    
                    const angle = Math.random() * Math.PI * 2;
                    const vel = Math.random() * 50 + 20;
                    p.style.setProperty('--dx', Math.cos(angle)*vel + 'px');
                    p.style.setProperty('--dy', Math.sin(angle)*vel + 'px');
                    
                    document.getElementById('grid').appendChild(p);
                    setTimeout(()=>p.remove(), 600);
                }
            },

            floatText(r, c, txt) {
                const el = document.createElement('div');
                el.className = 'floater';
                el.innerText = txt;
                el.style.left = (c*cfg.size + 10) + 'px';
                el.style.top = (r*cfg.size) + 'px';
                document.getElementById('grid').appendChild(el);
                setTimeout(()=>el.remove(), 1000);
            },

            checkWin() {
                if(state.score >= state.target) {
                    this.gameOver(true);
                } else if (state.moves <= 0) {
                    this.gameOver(false);
                }
            },

            gameOver(win) {
                state.locked = true;
                setTimeout(() => {
                    const res = document.getElementById('screen-result');
                    ui.nav('screen-result');
                    if(win) {
                        audioSys.sfx('win');
                        document.getElementById('res-title').innerText = "Sweet Victory!";
                        document.getElementById('res-msg').innerText = "You earned 50 Coins!";
                        state.coins += 50;
                    } else {
                        document.getElementById('res-title').innerText = "Out of Moves";
                        document.getElementById('res-msg').innerText = "Try buying more boosters!";
                    }
                    ui.updateShop();
                }, 500);
            },

            wait(ms) { return new Promise(r => setTimeout(r, ms)); }
        };

        const powerups = {
            activate(tool) {
                if(state.locked) return;
                if(state.inventory[tool] > 0) {
                    if(state.activeTool === tool) {
                        state.activeTool = null;
                        document.getElementById('grid').classList.remove('mode-active');
                    } else {
                        state.activeTool = tool;
                        document.getElementById('grid').classList.add('mode-active');
                        if(tool === 'shuffle') {
                            state.inventory.shuffle--;
                            this.doShuffle();
                            state.activeTool = null;
                            document.getElementById('grid').classList.remove('mode-active');
                            ui.updateShop();
                        }
                    }
                } else {
                    alert("Buy more in the shop!");
                }
            },
            use(r, c) {
                if(!state.activeTool) return;
                
                const tool = state.activeTool;
                state.inventory[tool]--;
                state.activeTool = null;
                document.getElementById('grid').classList.remove('mode-active');
                ui.updateShop();
                
                if(tool === 'hammer') {
                    audioSys.sfx('match');
                    this.destroyAt(r, c);
                }
                if(tool === 'bomb') {
                    audioSys.sfx('match');
                    for(let i=r-1; i<=r+1; i++) {
                        for(let j=c-1; j<=c+1; j++) {
                            if(i>=0 && i<cfg.h && j>=0 && j<cfg.w) this.destroyAt(i, j);
                        }
                    }
                }
                setTimeout(() => game.applyGravity(), 300);
            },
            destroyAt(r, c) {
                if(grid[r][c] !== -1) {
                    const el = domGrid[r][c];
                    game.createParticles(r, c, el.innerText);
                    el.style.transform = `${el.style.transform} scale(0)`;
                    grid[r][c] = -1;
                }
            },
            doShuffle() {
                let flat = [];
                for(let r=0; r<cfg.h; r++) for(let c=0; c<cfg.w; c++) if(grid[r][c]!==-1) flat.push(grid[r][c]);
                
                for(let i=flat.length-1; i>0; i--) {
                    const j = Math.floor(Math.random() * (i+1));
                    [flat[i], flat[j]] = [flat[j], flat[i]];
                }
                
                let k=0;
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(grid[r][c]!==-1) {
                            grid[r][c] = flat[k++];
                            domGrid[r][c].innerText = emojis[grid[r][c]];
                            domGrid[r][c].style.transform = `scale(0)`;
                            setTimeout(() => {
                                domGrid[r][c].style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px) scale(1)`;
                            }, 50 + k*10);
                        }
                    }
                }
                game.resetHint();
            }
        };

        const market = {
            buy(item) {
                const prices = { hammer: 100, bomb: 250, shuffle: 150 };
                const msg = document.getElementById('shop-msg');
                if(state.coins >= prices[item]) {
                    state.coins -= prices[item];
                    state.inventory[item]++;
                    msg.innerText = "Purchased!";
                    msg.style.color = "green";
                    ui.updateShop();
                } else {
                    msg.innerText = "Not enough coins!";
                    msg.style.color = "red";
                }
            }
        };

    </script>
</body>
</html>
