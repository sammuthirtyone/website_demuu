<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Jelly PoP - Blaster Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    
    <!-- ===============================
         CRAZYGAMES SDK v3 (REQUIRED)
    ================================ -->
    <script src="https://sdk.crazygames.com/crazygames-sdk-v3.js"></script>
    
    <!-- ===============================
         CRAZYGAMES v3 SAFE WRAPPER
    ================================ -->
    <script>
    window.CrazySDKSafe = {
        ready: false,
        isAdShowing: false,

        async init() {
            try {
                // Wait for SDK to be available
                if (!window.CrazyGames || !window.CrazyGames.SDK) {
                    console.log("‚è≥ Waiting for SDK to load...");
                    await new Promise(resolve => setTimeout(resolve, 500));
                    if (!window.CrazyGames || !window.CrazyGames.SDK) {
                        throw new Error("SDK not available");
                    }
                }
                
                await window.CrazyGames.SDK.init();
                this.ready = true;
                console.log("‚úÖ CrazyGames SDK v3 initialized");
                return true;
            } catch (e) {
                console.warn("‚ùå SDK init failed (game will still work)", e);
                return false;
            }
        },

        env() {
            try {
                return window.CrazyGames?.SDK?.environment || "disabled";
            } catch {
                return "disabled";
            }
        },

        loadingStart() {
            try {
                if (this.env() !== "disabled" && window.CrazyGames?.SDK?.game?.loadingStart) {
                    window.CrazyGames.SDK.game.loadingStart();
                }
            } catch (e) {}
        },

        loadingStop() {
            try {
                if (this.env() !== "disabled" && window.CrazyGames?.SDK?.game?.loadingStop) {
                    window.CrazyGames.SDK.game.loadingStop();
                }
            } catch (e) {}
        },

        gameplayStart() {
            try {
                if (this.env() !== "disabled" && window.CrazyGames?.SDK?.game?.gameplayStart) {
                    window.CrazyGames.SDK.game.gameplayStart();
                }
            } catch (e) {}
        },

        gameplayStop() {
            try {
                if (this.env() !== "disabled" && window.CrazyGames?.SDK?.game?.gameplayStop) {
                    window.CrazyGames.SDK.game.gameplayStop();
                }
            } catch (e) {}
        },

        async interstitialAd() {
            if (this.env() !== "crazygames" || this.isAdShowing) return;
            try {
                this.isAdShowing = true;
                await window.CrazyGames.SDK.ad.showInterstitialAd();
            } catch (e) {
                console.log("Interstitial skipped", e);
            } finally {
                this.isAdShowing = false;
            }
        },

        async rewardedAd(onReward) {
            if (this.env() !== "crazygames" || this.isAdShowing) return;
            try {
                this.isAdShowing = true;
                await window.CrazyGames.SDK.ad.showRewardedAd();
                if (onReward) onReward();
            } catch (e) {
                console.log("Rewarded failed", e);
            } finally {
                this.isAdShowing = false;
            }
        },

        async saveData(data) {
            if (this.env() !== "crazygames") return false;
            try {
                await window.CrazyGames.SDK.game.saveProgress(data);
                return true;
            } catch {
                return false;
            }
        },

        async loadData() {
            if (this.env() !== "crazygames") return null;
            try {
                return await window.CrazyGames.SDK.game.loadProgress();
            } catch {
                return null;
            }
        },

        submitScore(score) {
            try {
                if (this.env() === "crazygames" && window.CrazyGames?.SDK?.game?.submitScore) {
                    window.CrazyGames.SDK.game.submitScore(score);
                }
            } catch (e) {}
        }
    };
    </script>
    
    <style>
        /* all original styles ‚Äì unchanged */
        :root {
            --primary: #ff4081;
            --secondary: #00e5ff;
            --glass: rgba(255, 255, 255, 0.9);
            --tile-size: 45px;
        }
        body {
            margin: 0;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            background-image: radial-gradient(circle at 10% 20%, rgb(255, 197, 218) 0%, rgb(255, 120, 189) 90.1%);
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            background-image: radial-gradient(circle at 10% 20%, rgb(255, 197, 218) 0%, rgb(255, 120, 189) 90.1%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255,255,255,0.3);
            border-top-color: #ff4081;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        .loading-text {
            font-size: 1.2rem;
            color: #333;
            font-weight: 600;
        }
        .loading-progress {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        .loading-progress-bar {
            width: 0%;
            height: 100%;
            background: #ff4081;
            transition: width 0.3s;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: 0.3s;
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            z-index: 1;
        }
        .screen.active {
            opacity: 1;
            pointer-events: all;
            transform: scale(1);
            z-index: 10;
        }
        .panel {
            background: var(--glass);
            padding: 20px;
            border-radius: 30px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2), inset 0 0 0 5px rgba(255,255,255,0.5);
            text-align: center;
            width: 90%;
            max-width: 400px;
            backdrop-filter: blur(10px);
            animation: float 4s ease-in-out infinite;
        }
        h1 {
            font-size: 3rem;
            background: -webkit-linear-gradient(#ff00cc, #333399);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
            filter: drop-shadow(2px 2px 0px #fff);
        }
        .btn {
            background: linear-gradient(to bottom, #ffeb3b, #ffc107);
            border: none;
            border-radius: 50px;
            padding: 15px 40px;
            font-size: 1.5rem;
            color: #d32f2f;
            font-family: inherit;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 6px 0 #c69403, 0 10px 10px rgba(0,0,0,0.1);
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 2px 0 #c69403; }
        .btn-pink { background: linear-gradient(to bottom, #ff80ab, #f50057); color: white; box-shadow: 0 6px 0 #ad003d; }
        .btn-pink:active { box-shadow: 0 2px 0 #ad003d; }
        .btn-icon { padding: 10px; width: 50px; height: 50px; border-radius: 50%; font-size: 1.4rem; margin: 3px; }
        .level-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            padding: 10px;
            max-height: 250px; 
            overflow-y: auto; 
            scrollbar-width: thin;
        }
        .level-btn {
            width: 70px;
            height: 70px;
            border-radius: 20px;
            border: none;
            font-family: inherit;
            font-size: 1.5rem;
            color: white;
            cursor: pointer;
            background: linear-gradient(to bottom, #00e5ff, #00b0ff);
            box-shadow: 0 5px 0 #0081cb, 0 5px 10px rgba(0,0,0,0.2);
            transition: 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto; 
        }
        .level-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #0081cb; }
        .level-btn.locked { background: #e0e0e0; color: #999; box-shadow: 0 5px 0 #bdbdbd; cursor: not-allowed; }
        .level-btn.locked:active { transform: none; }
        .header-stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
            background: white;
            padding: 10px;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            box-sizing: border-box;
        }
        .stat div:first-child { font-size: 0.8rem; color: #888; }
        .stat div:last-child { font-size: 1.4rem; color: #333; }
        #board-container {
            position: relative;
            background: rgba(0,0,0,0.1);
            border-radius: 15px;
            padding: 10px;
            box-shadow: inset 0 4px 10px rgba(0,0,0,0.1);
        }
        .grid {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }
        .tile {
            position: absolute;
            width: 40px;
            height: 40px;
            left: 0; top: 0;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            touch-action: none; 
        }
        .tile-inner {
            position: relative; 
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            border-radius: 50%;
            backface-visibility: hidden;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2));
        }
        .tile.selected { z-index: 20; }
        .tile.selected .tile-inner::after {
            content: '';
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            animation: pulse 0.8s infinite;
            pointer-events: none;
            left: 0; top: 0;
        }
        .tile.hint .tile-inner { 
            animation: shake 2s infinite; 
            filter: brightness(1.3); 
        }
        .tile.blaster .tile-inner {
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,215,0,0.4) 70%);
            box-shadow: 0 0 10px 2px #fff, 0 0 15px 5px gold;
            border: 2px solid #fff;
            animation: blastPulse 1s infinite alternate;
            z-index: 15;
        }
        .tile.blaster .tile-inner::before {
            content: '‚≠ê';
            position: absolute;
            font-size: 10px;
            top: 0; right: 0;
            text-shadow: 0 0 2px black;
            z-index: 20;
        }
        @keyframes blastPulse { 0% { transform: scale(1); filter: brightness(1); } 100% { transform: scale(1.1); filter: brightness(1.3); } }
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: pop 0.6s ease-out forwards;
        }
        .shop-item {
            display: flex;
            align-items: center;
            background: #fff;
            margin: 10px 0;
            padding: 15px;
            border-radius: 15px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .shop-item:hover { border-color: gold; transform: scale(1.02); }
        .shop-price { background: #ffd700; color: #8a6e02; padding: 5px 10px; border-radius: 10px; font-size: 0.9rem; white-space: nowrap; }
        @keyframes pulse { 0% { transform: scale(0.9); } 50% { transform: scale(1.1); } 100% { transform: scale(0.9); } }
        @keyframes pop { 0% { transform: translate(0,0) scale(1); opacity: 1; } 100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        .floater {
            position: absolute;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            font-size: 1.5rem;
            pointer-events: none;
            animation: floatUp 1.5s forwards;
            z-index: 100;
            white-space: nowrap;
        }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-60px) scale(1.2); opacity: 0; } }
        .mode-active { cursor: crosshair !important; border: 4px solid red; }
        .mode-free { border: 4px solid #ff4081; animation: pulse 0.5s infinite; }
        
        /* Exit Fullscreen Button */
        .exit-fullscreen-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.9);
            border: 2px solid #ff4081;
            color: #ff4081;
            font-size: 1.2rem;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
        }
        .exit-fullscreen-btn.visible {
            display: flex;
        }
        
        .sync-indicator {
            position: fixed;
            top: 20px;
            right: 80px;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            color: #ff4081;
            border: 1px solid #ff4081;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            font-family: 'Fredoka One', cursive;
            pointer-events: none;
        }
        .sync-indicator.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Jelly Pop...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="loadingProgressBar" style="width: 0%;"></div>
        </div>
        <div class="sdk-status" style="margin-top:10px; color:#666; font-size:0.9rem;" id="sdkStatus">üöÄ Starting game...</div>
    </div>

    <!-- Exit Fullscreen Button -->
    <button class="exit-fullscreen-btn" id="exitFullscreenBtn" aria-label="Exit Fullscreen">‚§¨</button>

    <!-- Sync Indicator -->
    <div class="sync-indicator" id="syncIndicator">üíæ Saved to Cloud</div>

    <div style="position:absolute; top:10px; right:10px; z-index:100;">
        <button id="btn-sound" class="btn btn-icon" style="width:40px; height:40px; font-size:1.2rem; padding:0;">üîá</button>
    </div>

    <div id="screen-home" class="screen active">
        <div class="panel">
            <h1>Jelly<br>Pop</h1>
            <p>Blaster Edition</p>
            <button class="btn" onclick="ui.nav('screen-levels')">PLAY</button>
            <button class="btn btn-pink" onclick="ui.nav('screen-shop')">SHOP</button>
        </div>
    </div>

    <div id="screen-levels" class="screen">
        <div class="panel">
            <h2>Select Level</h2>
            <div id="level-container" class="level-grid"></div>
            <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">Scroll for more üëá</div>
            <button class="btn btn-pink" onclick="ui.nav('screen-home')" style="font-size:1rem; padding:10px 30px;">Back Home</button>
        </div>
    </div>

    <div id="screen-game" class="screen">
        <div class="panel" style="width: 100%; max-width: 380px; padding: 10px; background: rgba(255,255,255,0.7);">
            <div class="header-stats">
                <div class="stat"><div>LVL</div><div id="ui-lvl-num">1</div></div>
                <div class="stat"><div>MOVES</div><div id="ui-moves">20</div></div>
                <div class="stat"><div>TARGET</div><div id="ui-target">1000</div></div>
                <div class="stat"><div>SCORE</div><div id="ui-score">0</div></div>
            </div>
            <div style="width:100%; height:10px; background:#ddd; border-radius:5px; margin-bottom:10px; overflow:hidden;">
                <div id="score-bar" style="height:100%; width:0%; background:#00e5ff; transition:width 0.5s;"></div>
            </div>
            <div id="board-container">
                <div id="grid" class="grid"></div>
            </div>
            <div style="margin-top:10px; display:flex; justify-content:center; flex-wrap:wrap; gap:5px;">
                <button class="btn btn-pink btn-icon" id="btn-hammer" onclick="powerups.activate('hammer')">üî®<span style="font-size:0.6rem">1</span></button>
                <button class="btn btn-pink btn-icon" id="btn-bomb" onclick="powerups.activate('bomb')">üí£<span style="font-size:0.6rem">0</span></button>
                <button class="btn btn-pink btn-icon" id="btn-shuffle" onclick="powerups.activate('shuffle')">üîÑ<span style="font-size:0.6rem">1</span></button>
                <button class="btn btn-pink btn-icon" id="btn-cocoteddy" onclick="powerups.activate('cocoteddy')">üß∏<span style="font-size:0.6rem">0</span></button>
                <button class="btn btn-pink btn-icon" id="btn-candycane" onclick="powerups.activate('candycane')">üç≠<span style="font-size:0.6rem">0</span></button>
            </div>
            <button style="margin-top:5px; background:transparent; border:none; color:#666;" onclick="game.gameOver(false)">Give Up</button>
        </div>
    </div>

    <div id="screen-shop" class="screen">
        <div class="panel">
            <h2>Market</h2>
            <div style="margin-bottom:10px;">Coins: <span id="shop-coins" style="color:#e6b800; font-size:1.5rem;">1000</span></div>
            <div class="shop-item" onclick="market.buy('hammer')">
                <div style="font-size:2rem; margin-right:10px;">üî®</div>
                <div style="text-align:left; flex:1"><div>Smash</div><div style="font-size:0.7rem; color:#888;">Destroy 1 candy</div></div>
                <div class="shop-price">450</div>
            </div>
            <div class="shop-item" onclick="market.buy('bomb')">
                <div style="font-size:2rem; margin-right:10px;">üí£</div>
                <div style="text-align:left; flex:1"><div>Bomb</div><div style="font-size:0.7rem; color:#888;">Destroy 3x3 area</div></div>
                <div class="shop-price">999</div>
            </div>
            <div class="shop-item" onclick="market.buy('shuffle')">
                <div style="font-size:2rem; margin-right:10px;">üîÑ</div>
                <div style="text-align:left; flex:1"><div>Shuffle</div><div style="font-size:0.7rem; color:#888;">Mix the board</div></div>
                <div class="shop-price">350</div>
            </div>
            <div class="shop-item" onclick="market.buy('cocoteddy')">
                <div style="font-size:2rem; margin-right:10px;">üß∏</div>
                <div style="text-align:left; flex:1"><div>Coco Teddy</div><div style="font-size:0.7rem; color:#888;">5s Free Swaps</div></div>
                <div class="shop-price">799</div>
            </div>
            <div class="shop-item" onclick="market.buy('candycane')">
                <div style="font-size:2rem; margin-right:10px;">üç≠</div>
                <div style="text-align:left; flex:1"><div>Candy Cane</div><div style="font-size:0.7rem; color:#888;">Spawn 3x3 Match</div></div>
                <div class="shop-price">999</div>
            </div>
            <div id="shop-msg" style="height:20px; color:red; font-size:0.8rem; transition: opacity 0.5s;"></div>
            <button class="btn" onclick="ui.nav('screen-home')">Back</button>
        </div>
    </div>

    <div id="screen-result" class="screen" style="z-index:20; background:rgba(0,0,0,0.8);">
        <div class="panel">
            <h1 id="res-title">Won!</h1>
            <div id="res-stars" style="font-size:3rem;">‚≠ê‚≠ê‚≠ê</div>
            <p id="res-msg">Score: 5000</p>
            <div id="res-btns"></div>
        </div>
    </div>

    <script>
        /* ===============================
           REQUIRED: DISABLE PAGE SCROLL
        ================================ */
        window.addEventListener("wheel", e => e.preventDefault(), { passive: false });
        window.addEventListener("keydown", e => {
            if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key))
                e.preventDefault();
        });

        // Force hide loading screen after timeout (fallback)
        setTimeout(() => {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen && !loadingScreen.classList.contains('hidden')) {
                console.log("‚ö†Ô∏è Force hiding loading screen");
                loadingScreen.classList.add('hidden');
            }
        }, 5000);
    </script>

    <script>
        // Helper function to update loading status
        function updateLoadingStatus(text, progress) {
            const statusEl = document.getElementById('sdkStatus');
            const progressBar = document.getElementById('loadingProgressBar');
            
            if (statusEl) statusEl.textContent = text;
            if (progressBar) progressBar.style.width = progress + '%';
        }

        // --- LEVEL CONFIGURATION - Only store as data, not as DOM elements ---
        const levelData = [];
        for(let i=1; i<=300; i++){
            let moves = 25 + Math.floor(i * 2.5);
            let target = 500 + (i * 200);
            let reward = 50 + (i * 10);
            if(i % 5 === 0) { moves += 10; target += 1000; reward += 50; }
            levelData.push({id:i, moves: moves, target: target, reward: reward});
        }

        // Audio system - with background music
        const audioSys = {
            ctx: null,
            isMuted: true,
            isPlaying: false,
            musicInterval: null,
            
            init() {
                if(!this.ctx) {
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    } catch(e) {
                        console.log('Audio not supported');
                    }
                }
            },
            
            toggle() {
                this.init();
                this.isMuted = !this.isMuted;
                document.getElementById('btn-sound').innerText = this.isMuted ? 'üîá' : 'üîä';
                if(!this.isMuted && !this.isPlaying) this.playMusic();
                if(this.isMuted) this.stopMusic();
            },
            
            playNote(freq, type, dur, vol=0.1) {
                if(this.isMuted || !this.ctx) return;
                try {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.value = freq;
                    gain.gain.value = vol;
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + dur);
                } catch(e) {}
            },
            
            playMusic() {
                if(this.isMuted || this.isPlaying) return;
                this.isPlaying = true;
                let note = 0;
                const melody = [392, 523, 659, 783, 659, 523]; 
                this.musicInterval = setInterval(() => {
                    if(this.isMuted) { 
                        this.stopMusic(); 
                        return; 
                    }
                    this.playNote(melody[note % melody.length], 'sine', 0.5, 0.05);
                    note++;
                }, 400);
            },
            
            stopMusic() {
                this.isPlaying = false;
                if(this.musicInterval) {
                    clearInterval(this.musicInterval);
                    this.musicInterval = null;
                }
            },
            
            sfx(name) {
                if(this.isMuted) return;
                switch(name) {
                    case 'swap': this.playNote(400, 'sine', 0.1); break;
                    case 'match': 
                        this.playNote(600, 'triangle', 0.1); 
                        setTimeout(()=>this.playNote(800, 'triangle', 0.1), 100);
                        break;
                    case 'blaster':
                        this.playNote(200, 'sawtooth', 0.2);
                        setTimeout(()=>this.playNote(100, 'square', 0.4), 100);
                        break;
                    case 'bad': this.playNote(150, 'sawtooth', 0.3); break;
                    case 'win': 
                        [0, 0.2, 0.4].forEach((t, i) => setTimeout(() => this.playNote(500 + i*200, 'square', 0.3), t*1000));
                        break;
                    case 'shuffle': this.playNote(300, 'sawtooth', 0.3); break;
                    case 'magic': this.playNote(900, 'sine', 0.5); break;
                }
            }
        };

        const cfg = { w: 8, h: 8, size: 40 };
        const emojis = ['üçá', 'üçä', 'ü••', 'üç≠', 'üßÅ', 'üç©','üç´','üç¨']; 
        
        // Game state
        let grid = []; 
        let domGrid = []; 
        const state = {
            selected: null,
            locked: false,
            score: 0,
            moves: 0,
            target: 0,
            levelIdx: 0, 
            maxUnlocked: 1, 
            inventory: { hammer: 1, bomb: 0, shuffle: 1, cocoteddy: 0, candycane: 0 },
            coins: 1000, 
            activeTool: null,
            freeMove: false,
            visibleLevels: 9 // Only show 9 levels at a time for instant loading
        };
        
        let hintTimer = null;

        // UI Helper
        const ui = {
            nav(id) {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                if(id === 'screen-shop') this.updateShop();
                if(id === 'screen-levels') this.buildLevelSelect();
            },
            
            buildLevelSelect() {
                const con = document.getElementById('level-container');
                con.innerHTML = '';
                
                // Only load the first 9 levels initially for instant loading
                const startIdx = 0;
                const endIdx = Math.min(state.visibleLevels, levelData.length);
                
                for(let idx = startIdx; idx < endIdx; idx++) {
                    const lvl = levelData[idx];
                    const btn = document.createElement('button');
                    const isLocked = (idx + 1) > state.maxUnlocked;
                    btn.className = `level-btn ${isLocked ? 'locked' : ''}`;
                    btn.innerHTML = isLocked ? 'üîí' : (idx + 1);
                    if(!isLocked) {
                        btn.onclick = () => game.startLevel(idx);
                    }
                    con.appendChild(btn);
                }
                
                // Add a "More Levels" button if there are more
                if(state.visibleLevels < levelData.length) {
                    const moreBtn = document.createElement('button');
                    moreBtn.className = 'level-btn';
                    moreBtn.innerHTML = '‚ûï';
                    moreBtn.onclick = () => this.loadMoreLevels();
                    con.appendChild(moreBtn);
                }
            },
            
            loadMoreLevels() {
                state.visibleLevels += 9;
                this.buildLevelSelect();
            },
            
            updateStats() {
                document.getElementById('ui-lvl-num').innerText = state.levelIdx + 1;
                document.getElementById('ui-score').innerText = state.score;
                document.getElementById('ui-moves').innerText = state.moves;
                const pct = Math.min(100, (state.score / state.target) * 100);
                document.getElementById('score-bar').style.width = pct + '%';
                document.getElementById('ui-target').innerText = state.target;
            },
            
            updateShop() {
                document.getElementById('shop-coins').innerText = state.coins;
                ['hammer','bomb','shuffle','cocoteddy','candycane'].forEach(t => {
                    const btn = document.getElementById(`btn-${t}`);
                    if(btn) {
                        const icon = t==='hammer'?'üî®':t==='bomb'?'üí£':t==='shuffle'?'üîÑ':t==='cocoteddy'?'üß∏':'üç≠';
                        btn.innerHTML = `${icon} <span style="font-size:0.6rem">${state.inventory[t]}</span>`;
                    }
                });
            }
        };

        // Main Game Object
        const game = {
            startLevel(idx) {
                state.levelIdx = idx;
                const config = levelData[idx];
                state.moves = config.moves;
                state.target = config.target;
                state.score = 0;
                state.locked = false;
                state.activeTool = null;
                state.freeMove = false;
                document.getElementById('grid').classList.remove('mode-active', 'mode-free');
                
                // Start music when game begins (if unmuted)
                audioSys.init();
                if(!audioSys.isMuted) audioSys.playMusic();
                
                // Tell CrazyGames gameplay has started
                CrazySDKSafe.gameplayStart();
                
                ui.nav('screen-game');
                this.buildGrid();
                ui.updateStats();
                ui.updateShop();
                this.resetHint();
            },

            buildGrid() {
                const con = document.getElementById('grid');
                con.innerHTML = '';
                grid = [];
                domGrid = [];

                for(let r=0; r<cfg.h; r++) {
                    let row = [];
                    let dRow = [];
                    for(let c=0; c<cfg.w; c++) {
                        let type;
                        do {
                            type = Math.floor(Math.random() * emojis.length);
                        } while(
                            (r>=2 && grid[r-1] && grid[r-1][c]===type && grid[r-2][c]===type) ||
                            (c>=2 && row[c-1]===type && row[c-2]===type)
                        );
                        
                        row.push(type);
                        const el = this.createTile(r, c, type);
                        con.appendChild(el);
                        dRow.push(el);
                    }
                    grid.push(row);
                    domGrid.push(dRow);
                }
            },

            createTile(r, c, type) {
                const el = document.createElement('div');
                el.className = 'tile';
                el.style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px)`;
                
                const inner = document.createElement('div');
                inner.className = 'tile-inner';
                inner.innerText = emojis[type];
                el.appendChild(inner);

                el.dataset.r = r;
                el.dataset.c = c;
                this.attachInput(el);
                return el;
            },

            attachInput(el) {
                let startX, startY;
                let isDragging = false;

                el.ondragstart = () => false;

                const start = (e) => {
                    e.preventDefault();
                    game.resetHint();

                    if(state.locked && !state.freeMove) return;
                    
                    const r = parseInt(el.dataset.r);
                    const c = parseInt(el.dataset.c);
                    
                    if(state.activeTool) {
                        powerups.use(r, c);
                        return;
                    }

                    isDragging = true;
                    const t = e.touches ? e.touches[0] : e;
                    startX = t.clientX;
                    startY = t.clientY;
                    
                    if(!state.selected) {
                        this.select(r, c);
                    } else if (state.selected.r === r && state.selected.c === c) {
                        this.deselect();
                        isDragging = false;
                    } else {
                        const dr = Math.abs(state.selected.r - r);
                        const dc = Math.abs(state.selected.c - c);
                        if(dr + dc === 1) {
                            const oldSel = {...state.selected};
                            this.deselect();
                            this.attemptSwap(oldSel, {r, c});
                            isDragging = false;
                        } else {
                            this.select(r, c); 
                        }
                    }
                };

                const move = (e) => {
                    e.preventDefault();
                    if(!isDragging || !state.selected || (state.locked && !state.freeMove)) return;
                    
                    const r = parseInt(el.dataset.r);
                    const c = parseInt(el.dataset.c);
                    
                    if(state.selected.r !== r || state.selected.c !== c) return; 

                    const t = e.touches ? e.touches[0] : e;
                    const dx = t.clientX - startX;
                    const dy = t.clientY - startY;
                    
                    if(Math.abs(dx) > 15 || Math.abs(dy) > 15) {
                        isDragging = false;
                        let targetR = r;
                        let targetC = c;
                        
                        if(Math.abs(dx) > Math.abs(dy)) {
                            targetC += dx > 0 ? 1 : -1;
                        } else {
                            targetR += dy > 0 ? 1 : -1;
                        }
                        
                        if(targetR >=0 && targetR < cfg.h && targetC >= 0 && targetC < cfg.w) {
                            this.attemptSwap({r, c}, {r:targetR, c:targetC});
                        }
                        this.deselect(); 
                    }
                };

                const end = () => { isDragging = false; };

                el.addEventListener('mousedown', start);
                el.addEventListener('touchstart', start, {passive: false});
                el.addEventListener('mousemove', move); 
                el.addEventListener('touchmove', move, {passive: false});
                el.addEventListener('mouseup', end);
                el.addEventListener('mouseleave', end);
                el.addEventListener('touchend', end);
            },

            select(r, c) {
                this.deselect();
                state.selected = {r, c};
                if(domGrid[r] && domGrid[r][c]) {
                    domGrid[r][c].classList.add('selected');
                }
                audioSys.sfx('swap');
            },
            
            deselect() {
                if(state.selected) {
                    const {r, c} = state.selected;
                    if(domGrid[r] && domGrid[r][c]) {
                        domGrid[r][c].classList.remove('selected');
                    }
                    state.selected = null;
                }
            },

            resetHint() {
                clearTimeout(hintTimer);
                document.querySelectorAll('.hint').forEach(e => e.classList.remove('hint'));
                hintTimer = setTimeout(() => this.showHint(), 5000); 
            },

            showHint() {
                if(state.locked) return;
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(c<cfg.w-1) {
                            if(this.testSwap(r, c, r, c+1)) {
                                if(domGrid[r] && domGrid[r][c] && domGrid[r][c+1]) {
                                    domGrid[r][c].classList.add('hint');
                                    domGrid[r][c+1].classList.add('hint');
                                }
                                return;
                            }
                        }
                        if(r<cfg.h-1) {
                            if(this.testSwap(r, c, r+1, c)) {
                                if(domGrid[r] && domGrid[r][c] && domGrid[r+1] && domGrid[r+1][c]) {
                                    domGrid[r][c].classList.add('hint');
                                    domGrid[r+1][c].classList.add('hint');
                                }
                                return;
                            }
                        }
                    }
                }
            },

            testSwap(r1, c1, r2, c2) {
                if(!grid[r1] || !grid[r2]) return false;
                let temp = grid[r1][c1];
                grid[r1][c1] = grid[r2][c2];
                grid[r2][c2] = temp;
                const hasMatch = this.findMatches().length > 0;
                grid[r2][c2] = grid[r1][c1];
                grid[r1][c1] = temp;
                return hasMatch;
            },

            async attemptSwap(p1, p2) {
                state.locked = true;
                this.resetHint();
                
                await this.animSwap(p1, p2);
                this.swapData(p1.r, p1.c, p2.r, p2.c);
                
                const matches = this.findMatches();
                
                if(matches.length > 0 || state.freeMove) {
                    if(!state.freeMove) state.moves--;
                    ui.updateStats();
                    await this.processMatches(matches);
                } else {
                    audioSys.sfx('bad');
                    await this.animSwap(p1, p2); 
                    this.swapData(p1.r, p1.c, p2.r, p2.c); 
                    state.locked = false;
                    this.resetHint();
                }
            },

            swapData(r1, c1, r2, c2) {
                if(!grid[r1] || !grid[r2]) return;
                // Swap grid data
                let temp = grid[r1][c1];
                grid[r1][c1] = grid[r2][c2];
                grid[r2][c2] = temp;
                
                // Swap DOM references
                let tEl = domGrid[r1][c1];
                domGrid[r1][c1] = domGrid[r2][c2];
                domGrid[r2][c2] = tEl;
                
                // Update data attributes
                if(domGrid[r1][c1]) { 
                    domGrid[r1][c1].dataset.r = r1; 
                    domGrid[r1][c1].dataset.c = c1; 
                }
                if(domGrid[r2][c2]) { 
                    domGrid[r2][c2].dataset.r = r2; 
                    domGrid[r2][c2].dataset.c = c2; 
                }
            },

            animSwap(p1, p2) {
                return new Promise(resolve => {
                    if(!domGrid[p1.r] || !domGrid[p1.r][p1.c] || !domGrid[p2.r] || !domGrid[p2.r][p2.c]) {
                        resolve();
                        return;
                    }
                    const t1 = domGrid[p1.r][p1.c]; 
                    const t2 = domGrid[p2.r][p2.c];
                    t1.style.transform = `translate(${p2.c*cfg.size}px, ${p2.r*cfg.size}px)`;
                    t2.style.transform = `translate(${p1.c*cfg.size}px, ${p1.r*cfg.size}px)`;
                    setTimeout(() => resolve(), 250);
                });
            },

            findMatches() {
                let matched = new Set();
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w-2; c++) {
                        if(!grid[r] || grid[r][c] === -1) continue;
                        let t = grid[r][c];
                        let matchLen = 1;
                        while(c+matchLen < cfg.w && grid[r][c+matchLen] === t) matchLen++;
                        if(matchLen >= 3) {
                            for(let k=0; k<matchLen; k++) matched.add(`${r},${c+k}`);
                            c += matchLen - 1; 
                        }
                    }
                }
                for(let c=0; c<cfg.w; c++) {
                    for(let r=0; r<cfg.h-2; r++) {
                        if(!grid[r] || grid[r][c] === -1) continue;
                        let t = grid[r][c];
                        let matchLen = 1;
                        while(r+matchLen < cfg.h && grid[r+matchLen][c] === t) matchLen++;
                        if(matchLen >= 3) {
                            for(let k=0; k<matchLen; k++) matched.add(`${r+k},${c}`);
                            r += matchLen - 1;
                        }
                    }
                }
                return Array.from(matched).map(s => {
                    const [r, c] = s.split(',').map(Number);
                    return {r, c};
                });
            },

            async processMatches(matches) {
                this.deselect();

                if(!matches || matches.length === 0) {
                    state.locked = false;
                    this.resetHint();
                    return;
                }

                let createBlaster = false;
                let blasterPos = null;

                if (matches.length >= 4) {
                    createBlaster = true;
                    const m = matches[Math.floor(matches.length/2)];
                    blasterPos = {r: m.r, c: m.c};
                }

                const removals = new Set();
                for (let m of matches) removals.add(`${m.r},${m.c}`);

                let baseScore = matches.length * 10;
                let bonus = matches.length > 3 ? (matches.length-3)*10 : 0;
                let extraBlastSet = new Set();

                for (let m of matches) {
                    const el = domGrid[m.r] ? domGrid[m.r][m.c] : null;
                    if (el && el.classList.contains('blaster')) {
                        baseScore += 150;
                        this.floatText(m.r, m.c, "BLAST! +150");
                        audioSys.sfx('blaster');
                        this.createParticles(m.r, m.c, "‚≠ê");

                        for (let i = m.r - 1; i <= m.r + 1; i++) {
                            for (let j = m.c - 1; j <= m.c + 1; j++) {
                                if (i >= 0 && i < cfg.h && j >= 0 && j < cfg.w && grid[i] && grid[i][j] !== -1) {
                                    extraBlastSet.add(`${i},${j}`);
                                }
                            }
                        }
                        extraBlastSet.add(`${m.r},${m.c}`);
                    }
                }

                for (let s of extraBlastSet) removals.add(s);

                state.score += baseScore + bonus;
                ui.updateStats();

                const center = matches[Math.floor(matches.length/2)];
                if(center) this.floatText(center.r, center.c, `+${baseScore+bonus}`);

                const removalsArray = Array.from(removals).map(s => s.split(',').map(Number));
                for (let [r, c] of removalsArray) {
                    if (createBlaster && blasterPos && r === blasterPos.r && c === blasterPos.c) {
                        continue;
                    }
                    const el = domGrid[r] ? domGrid[r][c] : null;
                    if (el) {
                        const inner = el.querySelector('.tile-inner');
                        const char = inner ? inner.innerText : '';
                        this.createParticles(r, c, char || '‚Ä¢');
                        el.style.transform = `${el.style.transform} scale(0)`;
                    }
                    if(grid[r]) grid[r][c] = -1;
                }

                if (createBlaster && blasterPos) {
                    const be = domGrid[blasterPos.r] ? domGrid[blasterPos.r][blasterPos.c] : null;
                    if (be) {
                        be.classList.add('blaster');
                        be.style.transform = `translate(${blasterPos.c*cfg.size}px, ${blasterPos.r*cfg.size}px) scale(1.2)`;
                        setTimeout(() => {
                            if(be) {
                                be.style.transform = `translate(${blasterPos.c*cfg.size}px, ${blasterPos.r*cfg.size}px) scale(1)`;
                            }
                        }, 200);
                        this.floatText(blasterPos.r, blasterPos.c, "BLASTER!");
                    }
                }

                await this.wait(300);
                
                // Clean up null DOM elements
                for(let r=0; r<cfg.h; r++){
                    for(let c=0; c<cfg.w; c++){
                        if(grid[r] && grid[r][c] === -1 && domGrid[r] && domGrid[r][c]) {
                            domGrid[r][c].remove();
                            domGrid[r][c] = null;
                        }
                    }
                }

                await this.applyGravity();
            },

            async applyGravity() {
                let moved = false;
                for(let c=0; c<cfg.w; c++) {
                    let emptySlots = 0;
                    for(let r=cfg.h-1; r>=0; r--) {
                        if(!grid[r]) continue;
                        if(grid[r][c] === -1) {
                            emptySlots++;
                        } else if (emptySlots > 0) {
                            let targetR = r + emptySlots;
                            if(!grid[targetR]) continue;
                            grid[targetR][c] = grid[r][c];
                            grid[r][c] = -1;
                            let el = domGrid[r][c];
                            domGrid[targetR][c] = el;
                            domGrid[r][c] = null;
                            if(el) {
                                el.dataset.r = targetR;
                                el.style.transform = `translate(${c*cfg.size}px, ${targetR*cfg.size}px)`;
                                moved = true;
                            }
                        }
                    }
                    for(let r=0; r<emptySlots; r++) {
                        if(!grid[r]) continue;
                        const type = Math.floor(Math.random() * emojis.length);
                        grid[r][c] = type;
                        const el = this.createTile(r, c, type);
                        el.style.transform = `translate(${c*cfg.size}px, -${cfg.size}px)`;
                        document.getElementById('grid').appendChild(el);
                        domGrid[r][c] = el;
                        requestAnimationFrame(() => {
                            el.style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px)`;
                        });
                        moved = true;
                    }
                }
                if(moved) {
                    await this.wait(400);
                    const newMatches = this.findMatches();
                    if(newMatches.length > 0) {
                        await this.processMatches(newMatches);
                    } else {
                        state.locked = false;
                        this.resetHint();
                        this.checkWin();
                        if(!state.freeMove) this.checkDeadlock();
                    }
                } else {
                    state.locked = false;
                    this.resetHint();
                    if(!state.freeMove) this.checkDeadlock();
                }
            },

            createParticles(r, c, char) {
                const gridEl = document.getElementById('grid');
                if(!gridEl) return;
                const x = c * cfg.size + 20;
                const y = r * cfg.size + 20;
                for(let i=0; i<6; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.innerText = char; 
                    p.style.fontSize = '12px';
                    p.style.left = x + 'px';
                    p.style.top = y + 'px';
                    const angle = Math.random() * Math.PI * 2;
                    const vel = Math.random() * 50 + 20;
                    p.style.setProperty('--dx', Math.cos(angle)*vel + 'px');
                    p.style.setProperty('--dy', Math.sin(angle)*vel + 'px');
                    gridEl.appendChild(p);
                    setTimeout(()=>p.remove(), 600);
                }
            },

            floatText(r, c, txt) {
                const gridEl = document.getElementById('grid');
                if(!gridEl) return;
                const el = document.createElement('div');
                el.className = 'floater';
                el.innerText = txt;
                el.style.left = (c*cfg.size + 10) + 'px';
                el.style.top = (r*cfg.size) + 'px';
                gridEl.appendChild(el);
                setTimeout(()=>el.remove(), 1500);
            },

            checkWin() {
                if(state.score >= state.target) {
                    this.gameOver(true);
                } else if (state.moves <= 0) {
                    this.gameOver(false);
                }
            },

            checkDeadlock() {
                let possible = false;
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(c<cfg.w-1 && this.testSwap(r, c, r, c+1)) possible = true;
                        if(r<cfg.h-1 && this.testSwap(r, c, r+1, c)) possible = true;
                        if(possible) return;
                    }
                }
                if(!possible) {
                    this.floatText(3, 3, "No Moves! Shuffle!");
                    setTimeout(() => powerups.doShuffle(), 1000);
                }
            },

            async gameOver(win) {
                state.locked = true;
                audioSys.stopMusic(); // Stop music when game ends
                
                // Tell CrazyGames gameplay has stopped
                CrazySDKSafe.gameplayStop();
                
                // Show an ad between levels (not too frequent)
                if (win) {
                    CrazySDKSafe.interstitialAd();
                }
                
                setTimeout(() => {
                    const btnContainer = document.getElementById('res-btns');
                    btnContainer.innerHTML = '';
                    
                    const btnMenu = document.createElement('button');
                    btnMenu.className = 'btn btn-pink';
                    btnMenu.innerText = 'Levels';
                    btnMenu.onclick = () => ui.nav('screen-levels');
                    
                    if(win) {
                        audioSys.sfx('win');
                        const reward = levelData[state.levelIdx] ? levelData[state.levelIdx].reward : 100;
                        document.getElementById('res-title').innerText = "Sweet Victory!";
                        document.getElementById('res-msg').innerText = `Level Complete! Earned ${reward} Coins!`;
                        state.coins += reward;
                        
                        // Save progress to cloud
                        CrazySDKSafe.saveData({
                            coins: state.coins,
                            maxUnlocked: state.maxUnlocked,
                            inventory: state.inventory
                        }).then(saved => {
                            if (saved) {
                                document.getElementById('syncIndicator').classList.add('visible');
                                setTimeout(() => {
                                    document.getElementById('syncIndicator').classList.remove('visible');
                                }, 2000);
                            }
                        });
                        
                        // Submit score to leaderboard
                        CrazySDKSafe.submitScore(state.score);
                        
                        if((state.levelIdx + 1) === state.maxUnlocked && state.maxUnlocked < levelData.length) state.maxUnlocked++;
                        if((state.levelIdx + 1) < levelData.length) {
                             const btnNext = document.createElement('button');
                             btnNext.className = 'btn';
                             btnNext.innerText = 'Next Level';
                             btnNext.onclick = () => game.startLevel(state.levelIdx + 1);
                             btnContainer.appendChild(btnNext);
                        }
                        btnContainer.appendChild(btnMenu);
                    } else {
                        document.getElementById('res-title').innerText = "Out of Moves";
                        document.getElementById('res-msg').innerText = "Don't give up!";
                        const btnRetry = document.createElement('button');
                        btnRetry.className = 'btn';
                        btnRetry.innerText = 'Try Again';
                        btnRetry.onclick = () => game.startLevel(state.levelIdx);
                        btnContainer.appendChild(btnRetry);
                        btnContainer.appendChild(btnMenu);
                    }
                    ui.nav('screen-result');
                    ui.updateShop();
                }, 500);
            },

            wait(ms) { return new Promise(r => setTimeout(r, ms)); }
        };

        // Powerups
        const powerups = {
            activate(tool) {
                if(state.locked && !state.freeMove) return;
                if(state.inventory[tool] > 0) {
                    if(state.activeTool === tool) {
                        state.activeTool = null;
                        document.getElementById('grid').classList.remove('mode-active');
                    } else {
                        if(tool === 'shuffle' || tool === 'cocoteddy') {
                            this.useInstant(tool);
                            return;
                        }
                        state.activeTool = tool;
                        document.getElementById('grid').classList.add('mode-active');
                    }
                } else {
                    market.showMsg("Buy in Shop!", "red");
                }
            },
            
            useInstant(tool) {
                state.inventory[tool]--;
                ui.updateShop();
                if(tool === 'shuffle') this.doShuffle();
                if(tool === 'cocoteddy') this.doCocoTeddy();
            },
            
            use(r, c) {
                if(!state.activeTool) return;
                const tool = state.activeTool;
                state.inventory[tool]--;
                state.activeTool = null;
                document.getElementById('grid').classList.remove('mode-active');
                ui.updateShop();
                if(tool === 'hammer') {
                    audioSys.sfx('match');
                    this.destroyAt(r, c);
                }
                if(tool === 'bomb') {
                    audioSys.sfx('match');
                    for(let i=r-1; i<=r+1; i++) {
                        for(let j=c-1; j<=c+1; j++) {
                            if(i>=0 && i<cfg.h && j>=0 && j<cfg.w) this.destroyAt(i, j);
                        }
                    }
                }
                if(tool === 'candycane') {
                    audioSys.sfx('magic');
                    this.doCandyCane(r, c);
                }
                setTimeout(() => game.applyGravity(), 300);
            },
            
            destroyAt(r, c) {
                if(grid[r] && grid[r][c] !== -1) {
                    const el = domGrid[r][c];
                    if(el) {
                        game.createParticles(r, c, el.querySelector('.tile-inner').innerText);
                        el.style.transform = `${el.style.transform} scale(0)`;
                    }
                    grid[r][c] = -1;
                }
            },
            
            doShuffle() {
                audioSys.sfx('shuffle');
                let flat = [];
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(grid[r] && grid[r][c] !== -1) flat.push(grid[r][c]);
                    }
                }
                for(let i=flat.length-1; i>0; i--) {
                    const j = Math.floor(Math.random() * (i+1));
                    [flat[i], flat[j]] = [flat[j], flat[i]];
                }
                let k=0;
                for(let r=0; r<cfg.h; r++) {
                    for(let c=0; c<cfg.w; c++) {
                        if(grid[r] && grid[r][c] !== -1) {
                            grid[r][c] = flat[k++];
                            if(domGrid[r] && domGrid[r][c]) {
                                const inner = domGrid[r][c].querySelector('.tile-inner');
                                if(inner) inner.innerText = emojis[grid[r][c]];
                                domGrid[r][c].classList.remove('blaster');
                                domGrid[r][c].style.transform = `scale(0)`;
                                setTimeout(() => {
                                    if(domGrid[r] && domGrid[r][c]) {
                                        domGrid[r][c].style.transform = `translate(${c*cfg.size}px, ${r*cfg.size}px) scale(1)`;
                                    }
                                }, 50 + k*10);
                            }
                        }
                    }
                }
                game.resetHint();
            },
            
            doCocoTeddy() {
                audioSys.sfx('magic');
                game.floatText(3, 3, "FREE MOVE 5s!");
                state.freeMove = true;
                document.getElementById('grid').classList.add('mode-free');
                let timeLeft = 5;
                const timer = setInterval(() => {
                    timeLeft--;
                    if(timeLeft <= 0) {
                        clearInterval(timer);
                        state.freeMove = false;
                        document.getElementById('grid').classList.remove('mode-free');
                        game.floatText(3, 3, "Time's Up!");
                        const matches = game.findMatches();
                        if(matches.length>0) game.processMatches(matches);
                    }
                }, 1000);
            },
            
            doCandyCane(r, c) {
                if(!grid[r]) return;
                const targetType = grid[r][c];
                if(targetType === -1) return;
                for(let i=r-1; i<=r+1; i++) {
                    for(let j=c-1; j<=c+1; j++) {
                        if(i>=0 && i<cfg.h && j>=0 && j<cfg.w && grid[i] && grid[i][j] !== -1) {
                            grid[i][j] = targetType;
                            if(domGrid[i] && domGrid[i][j]) {
                                const inner = domGrid[i][j].querySelector('.tile-inner');
                                if(inner) inner.innerText = emojis[targetType];
                                domGrid[i][j].style.transform = `translate(${j*cfg.size}px, ${i*cfg.size}px) scale(1.2)`;
                                setTimeout(() => {
                                    if(domGrid[i] && domGrid[i][j]) {
                                        domGrid[i][j].style.transform = `translate(${j*cfg.size}px, ${i*cfg.size}px) scale(1)`;
                                    }
                                }, 150);
                            }
                        }
                    }
                }
            }
        };

        // Market
        const market = {
            prices: { 'hammer': 450, 'bomb': 999, 'shuffle': 350, 'cocoteddy': 799, 'candycane': 999 },
            buy(type) {
                const cost = this.prices[type];
                if(state.coins >= cost) {
                    state.coins -= cost;
                    state.inventory[type]++;
                    audioSys.sfx('win');
                    ui.updateShop();
                    this.showMsg("Purchased!", "#00c853");
                    
                    // Save to cloud after purchase
                    CrazySDKSafe.saveData({
                        coins: state.coins,
                        maxUnlocked: state.maxUnlocked,
                        inventory: state.inventory
                    });
                } else {
                    audioSys.sfx('bad');
                    this.showMsg("Not enough coins!", "#d50000");
                }
            },
            showMsg(text, color) {
                const el = document.getElementById('shop-msg');
                el.style.color = color;
                el.innerText = text;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 1500);
            }
        };

        /* ===============================
           GAME BOOTSTRAP - FIXED SOUND BUTTON
        ================================ */
        window.onload = async () => {
            console.log('üöÄ Game loading...');
            
            // Tell CrazyGames loading has started
            CrazySDKSafe.loadingStart();
            
            // Initialize SDK (async, non-blocking)
            updateLoadingStatus('Initializing CrazyGames...', 20);
            await CrazySDKSafe.init();

            // Load saved data from cloud
            updateLoadingStatus('Loading cloud saves...', 40);
            try {
                const savedData = await CrazySDKSafe.loadData();
                if (savedData) {
                    state.coins = savedData.coins || 1000;
                    state.maxUnlocked = savedData.maxUnlocked || 1;
                    state.inventory = savedData.inventory || { hammer: 1, bomb: 0, shuffle: 1, cocoteddy: 0, candycane: 0 };
                    console.log('‚úÖ Cloud data loaded successfully');
                }
            } catch (e) {
                console.warn('Failed to load cloud data:', e);
            }

            // Initialize audio
            updateLoadingStatus('Initializing audio...', 60);
            audioSys.init();

            // Initialize with only first batch of levels
            ui.buildLevelSelect();
            
            // Hide loading screen
            updateLoadingStatus('Ready to play!', 100);
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                CrazySDKSafe.loadingStop();
                console.log('‚úÖ Game ready');
            }, 500);

            // FIXED: Set up sound button event listener properly
            const soundBtn = document.getElementById('btn-sound');
            soundBtn.onclick = function(e) {
                e.preventDefault();
                audioSys.toggle();
            };

            // Auto-unmute and play music on first interaction (browser policy)
            document.body.addEventListener('click', function initAudioOnFirstClick() {
                audioSys.init();
                if(!audioSys.isMuted) {
                    audioSys.playMusic();
                }
                document.body.removeEventListener('click', initAudioOnFirstClick);
            }, { once: true });
            
            // Fullscreen handling
            const exitFullscreenBtn = document.getElementById('exitFullscreenBtn');
            
            function updateFullscreenButton() {
                if (document.fullscreenElement) {
                    exitFullscreenBtn.classList.add('visible');
                } else {
                    exitFullscreenBtn.classList.remove('visible');
                }
            }
            
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            
            exitFullscreenBtn.onclick = () => {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            };
        };
    </script>
</body>
</html>
