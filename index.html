<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bucket Jump ¬∑ Adventure Mode</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            margin: 0;
            padding: 0;
        }
        body {
            background: #e0f7fa;
            background-image: radial-gradient(#b2ebf2 20%, transparent 20%);
            background-size: 30px 30px;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Fredoka One', cursive;
            overflow: hidden;
        }
        .game-wrapper {
            background: #ffffff;
            border: 8px solid #4dd0e1;
            padding: 10px;
            border-radius: 30px;
            box-shadow: 0 20px 50px rgba(77, 208, 225, 0.4);
            position: relative;
            max-width: 100%;
        }
        canvas {
            display: block;
            width: 100%;
            max-width: 1024px;
            height: auto;
            aspect-ratio: 16 / 9;
            border-radius: 20px;
            background: linear-gradient(to bottom, #e1f5fe, #ffffff);
            cursor: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
        }
        .ui-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
            padding: 0 10px;
        }
        .stat-badge {
            background: #e0f7fa;
            color: #0097a7;
            padding: 8px 20px;
            border-radius: 50px;
            font-size: 1.2rem;
            box-shadow: 0 4px 0 #b2ebf2;
            text-transform: uppercase;
            min-width: 120px;
            text-align: center;
        }
        .btn-group {
            display: flex;
            gap: 10px;
        }
        button {
            background: #4dd0e1;
            border: none;
            color: white;
            font-family: 'Fredoka One', cursive;
            font-size: 1rem;
            padding: 8px 20px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #00acc1;
            transition: all 0.1s;
        }
        button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        button:active { transform: translateY(4px); box-shadow: 0 0 0; }
        
        button.secondary { background: #b2dfdb; color: #00695c; box-shadow: 0 4px 0 #80cbc4; }

        /* Overlays */
        #menuOverlay, #winOverlay, #levelTransition {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            border-radius: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: opacity 0.3s;
        }

        #menuOverlay {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
        }
        
        #levelTransition {
            background: #4dd0e1;
            color: white;
            display: none;
            pointer-events: none;
        }

        .title-text {
            font-size: 4rem;
            color: #4dd0e1;
            text-shadow: 4px 4px 0 #b2ebf2;
            margin-bottom: 1rem;
            animation: float 3s ease-in-out infinite;
        }

        .play-btn {
            font-size: 2rem;
            padding: 15px 50px;
            background: #ff7043;
            box-shadow: 0 8px 0 #d84315;
        }
        
        .controls-hint {
            margin-top: 20px;
            display: flex;
            gap: 20px;
            color: #888;
        }
        
        .key {
            background: #eee;
            padding: 5px 10px;
            border-radius: 5px;
            border-bottom: 3px solid #ccc;
            font-family: monospace;
            font-weight: bold;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <canvas id="gameCanvas" width="1024" height="576"></canvas>

    <div class="ui-bar">
        <div class="stat-badge">
            üö© Level <span id="levelDisplay">1</span>/30
        </div>
        <div class="btn-group">
            <button class="secondary" id="restartBtn">‚Ü∫ Retry</button>
            <button class="secondary" id="soundToggle">üîä Sound</button>
            <button class="secondary" id="menuBtn">‚åÇ Home</button>
        </div>
        <div class="stat-badge" style="background: #fff9c4; color: #fbc02d;">
             ‚≠ê <span id="starDisplay">0</span>/3
        </div>
    </div>

    <div id="menuOverlay">
        <div class="title-text">BUCKET JUMP</div>
        <div style="font-size: 1.5rem; color: #555; margin-bottom: 20px;">Adventure Edition</div>
        <button class="play-btn" id="startBtn">START GAME</button>
        <div class="controls-hint">
            <div><span class="key">‚Üê</span> <span class="key">‚Üí</span> Move</div>
            <div><span class="key">SPACE</span> Jump</div>
        </div>
    </div>

    <div id="levelTransition">
        <div class="title-text" style="color: white; text-shadow: none;" id="levelTitle">LEVEL 1</div>
    </div>

    <div id="winOverlay" style="display: none; background: rgba(255,255,255,0.95);">
        <div class="title-text" style="color: #ffca28;">VICTORY!</div>
        <div style="font-size: 1.5rem; color: #555; margin-bottom: 30px;">You conquered all 30 levels!</div>
        <button class="play-btn" id="backToMenuBtn">PLAY AGAIN</button>
    </div>
</div>

<script>
(function() {
    // ---------- SETUP ----------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const levelSpan = document.getElementById('levelDisplay');
    const starSpan = document.getElementById('starDisplay');
    const menuOverlay = document.getElementById('menuOverlay');
    const winOverlay = document.getElementById('winOverlay');
    const transitionOverlay = document.getElementById('levelTransition');
    const levelTitle = document.getElementById('levelTitle');
    
    // Buttons
    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('restartBtn').onclick = () => resetLevel();
    document.getElementById('menuBtn').onclick = showMenu;
    document.getElementById('backToMenuBtn').onclick = showMenu;

    // ---------- SOUND MANAGER ----------
    class SoundManager {
        constructor() {
            this.enabled = true;
            this.ctx = null;
        }
        init() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        }
        playTone(freq, type, duration, vol=0.1) {
            if (!this.enabled) return;
            this.init();
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        }
        play(sfx) {
            if(!this.enabled) return;
            switch(sfx) {
                case 'jump': this.playTone(400, 'sine', 0.15); break;
                case 'land': this.playTone(100, 'sine', 0.1); break;
                case 'coin': 
                    this.playTone(1200, 'square', 0.1, 0.05); 
                    setTimeout(() => this.playTone(1600, 'square', 0.2, 0.05), 50);
                    break;
                case 'death': 
                    this.playTone(150, 'sawtooth', 0.4); 
                    this.playTone(100, 'sawtooth', 0.4); 
                    break;
                case 'win':
                    setTimeout(() => this.playTone(523, 'sine', 0.2), 0);
                    setTimeout(() => this.playTone(659, 'sine', 0.2), 150);
                    setTimeout(() => this.playTone(784, 'sine', 0.4), 300);
                    break;
            }
        }
        toggle() { this.enabled = !this.enabled; return this.enabled; }
    }

    const sound = new SoundManager();
    document.getElementById('soundToggle').onclick = function() {
        const on = sound.toggle();
        this.innerText = on ? 'üîä Sound' : 'üîá Mute';
        this.style.opacity = on ? 1 : 0.6;
    };

    // ---------- GAME CONSTANTS ----------
    const TOTAL_LEVELS = 30;
    const GRAVITY = 0.5;
    const FRICTION = 0.85;
    const MOVE_ACCEL = 0.6;
    const MAX_SPEED = 6; // Manageable speed
    const JUMP_FORCE = -11;
    
    // ---------- ENTITIES ----------
    
    class Player {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.w = 32; this.h = 32; 
            this.vx = 0; this.vy = 0;
            this.grounded = false;
            this.alive = true;
            this.facingRight = true;
            this.scaleX = 1; this.scaleY = 1;
            this.rotation = 0;
            
            // Coyote Time & Buffering
            this.coyoteTimer = 0; // Frames allowed to jump after leaving ground
            this.jumpBuffer = 0;  // Frames to remember jump press before landing
        }

        update(platforms, traps, stars, goal) {
            if (!this.alive) return;

            // --- MOVEMENT PHYSICS ---
            if (keys.left) {
                this.vx -= MOVE_ACCEL;
                this.facingRight = false;
            }
            if (keys.right) {
                this.vx += MOVE_ACCEL;
                this.facingRight = true;
            }

            // Friction (make stopping easier)
            this.vx *= FRICTION;
            
            // Cap Speed
            if(this.vx > MAX_SPEED) this.vx = MAX_SPEED;
            if(this.vx < -MAX_SPEED) this.vx = -MAX_SPEED;
            
            // Stop tiny sliding
            if(Math.abs(this.vx) < 0.1) this.vx = 0;

            // Gravity
            this.vy += GRAVITY;

            // --- JUMPING LOGIC ---
            if (this.grounded) {
                this.coyoteTimer = 6; // 6 frames grace period
            } else {
                this.coyoteTimer--;
            }

            if (keys.jumpPressed) {
                this.jumpBuffer = 5; // Remember jump for 5 frames
                keys.jumpPressed = false; // Consume press
            }

            if (this.jumpBuffer > 0) {
                this.jumpBuffer--;
                if (this.coyoteTimer > 0) {
                    this.performJump();
                }
            }
            
            // Variable Jump Height (release key to fall faster)
            if (!keys.jumpHeld && this.vy < 0) {
                this.vy *= 0.6;
            }

            // --- POSITION UPDATE X ---
            this.x += this.vx;
            this.handleCollisions(platforms, 'x');

            // --- POSITION UPDATE Y ---
            this.y += this.vy;
            this.grounded = false; // Assume in air until collision proves otherwise
            this.handleCollisions(platforms, 'y');

            // --- ANIMATION ---
            this.scaleX = lerp(this.scaleX, 1, 0.2);
            this.scaleY = lerp(this.scaleY, 1, 0.2);
            
            if (this.grounded) {
                this.rotation = lerp(this.rotation, 0, 0.3);
            } else {
                // Tilt forward slightly when moving
                let targetRot = (this.vx / MAX_SPEED) * 0.3;
                this.rotation = lerp(this.rotation, targetRot, 0.1);
            }

            // --- INTERACTION ---
            
            // Out of bounds
            if (this.y > 700) this.die();

            // Traps
            for (let t of traps) {
                if (t.active && this.collidesWithTrap(t)) this.die();
            }

            // Stars
            for (let s of stars) {
                if (!s.collected && this.collides(s)) {
                    s.collected = true;
                    sound.play('coin');
                    gameData.starsCollected++;
                    starSpan.innerText = gameData.starsCollected;
                    spawnParticles(s.x + 10, s.y + 10, '#ffd700', 5);
                }
            }

            // Goal
            if (gameData.starsCollected >= 3 && this.collides(goal)) {
                nextLevel();
            }
        }

        performJump() {
            this.vy = JUMP_FORCE;
            this.coyoteTimer = 0;
            this.jumpBuffer = 0;
            this.scaleX = 0.7; this.scaleY = 1.3;
            sound.play('jump');
            spawnParticles(this.x + this.w/2, this.y + this.h, '#fff', 4);
        }

        handleCollisions(platforms, axis) {
            for (let p of platforms) {
                if (!p.active) continue;
                
                if (this.collides(p)) {
                    if (axis === 'x') {
                        if (this.vx > 0) this.x = p.x - this.w;
                        else if (this.vx < 0) this.x = p.x + p.w;
                        this.vx = 0;
                    } 
                    else if (axis === 'y') {
                        if (this.vy > 0) { // Landing
                            this.y = p.y - this.h;
                            this.grounded = true;
                            if(this.vy > 2) { 
                                this.scaleX = 1.3; this.scaleY = 0.7; 
                                sound.play('land');
                            }
                            this.vy = 0;
                            
                            // Falling platform logic
                            if (p.type === 'fall') {
                                p.triggerFall();
                            }
                        } else if (this.vy < 0) { // Hitting head
                            this.y = p.y + p.h;
                            this.vy = 0;
                        }
                    }
                }
            }
        }

        collides(o) {
            return this.x < o.x + o.w && this.x + this.w > o.x &&
                   this.y < o.y + o.h && this.y + this.h > o.y;
        }

        collidesWithTrap(t) {
            // Forgiving hitbox for spikes (smaller than visual)
            const padding = 6; 
            return this.x + padding < t.x + t.w - padding &&
                   this.x + this.w - padding > t.x + padding &&
                   this.y + padding < t.y + t.h - padding &&
                   this.y + this.h - padding > t.y + padding;
        }

        die() {
            if (!this.alive) return;
            this.alive = false;
            sound.play('death');
            spawnExplosion(this.x + this.w/2, this.y + this.h/2);
            setTimeout(resetLevel, 700);
        }

        draw(ctx) {
            if(!this.alive) return;
            const cx = this.x + this.w/2;
            const cy = this.y + this.h;
            
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(this.rotation);
            ctx.scale(this.scaleX, this.scaleY);
            ctx.translate(-cx, -cy);

            // Bucket Body
            ctx.fillStyle = '#4dd0e1'; // Cyan
            ctx.strokeStyle = '#006064';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.w, this.y);
            ctx.lineTo(this.x + this.w - 5, this.y + this.h);
            ctx.lineTo(this.x + 5, this.y + this.h);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Rim
            ctx.fillStyle = '#80deea';
            ctx.beginPath();
            ctx.ellipse(cx, this.y, this.w/2, 5, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();

            // Eyes
            const eyeX = this.facingRight ? cx + 4 : cx - 4;
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(eyeX - 6, this.y + 16, 5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX + 6, this.y + 16, 5, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = 'black';
            const lookX = this.vx * 0.5;
            ctx.beginPath(); ctx.arc(eyeX - 6 + lookX, this.y + 16, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(eyeX + 6 + lookX, this.y + 16, 2, 0, Math.PI*2); ctx.fill();

            // Handle
            ctx.beginPath();
            ctx.arc(cx, this.y, this.w/2, Math.PI, 0);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }
    }

    class Platform {
        constructor(x, y, w, h, type = 'normal') {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.type = type; // normal, fall, move
            this.active = true;
            this.initialY = y;
            this.timer = Math.random() * 100;
            this.falling = false;
        }

        triggerFall() {
            if(!this.falling) {
                this.falling = true;
                setTimeout(() => { this.active = false; }, 500); // 0.5s delay before disappearing
            }
        }

        update() {
            if (this.type === 'move') {
                this.timer += 0.03;
                this.y = this.initialY + Math.sin(this.timer) * 50;
            }
            if (this.falling) {
                this.y += 2; // Shake/Sink effect
                this.x += (Math.random() - 0.5) * 2; // Shake
            }
        }

        draw(ctx) {
            if (!this.active) return;
            
            if (this.type === 'fall') {
                ctx.fillStyle = '#ffccbc'; // Crumbly color
                ctx.strokeStyle = '#ff7043';
            } else if (this.type === 'move') {
                ctx.fillStyle = '#c5cae9';
                ctx.strokeStyle = '#3f51b5';
            } else {
                ctx.fillStyle = '#c8e6c9';
                ctx.strokeStyle = '#43a047';
            }
            
            // Draw Block
            ctx.lineWidth = 2;
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.strokeRect(this.x, this.y, this.w, this.h);

            // Detail
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(this.x, this.y, this.w, 5);

            if (this.type === 'fall') {
                // Draw cracks
                ctx.beginPath();
                ctx.moveTo(this.x + 10, this.y);
                ctx.lineTo(this.x + 20, this.y + 15);
                ctx.lineTo(this.x + 15, this.y + 25);
                ctx.stroke();
            }
        }
    }

    class Trap {
        constructor(x, y, w, h) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.active = true;
        }
        update() {}
        draw(ctx) {
            ctx.fillStyle = '#ff5252';
            // Draw spikes
            const spikeCount = Math.floor(this.w / 10);
            ctx.beginPath();
            for(let i=0; i<spikeCount; i++) {
                const sx = this.x + (i * (this.w/spikeCount));
                ctx.lineTo(sx, this.y + this.h);
                ctx.lineTo(sx + (this.w/spikeCount)/2, this.y);
                ctx.lineTo(sx + (this.w/spikeCount), this.y + this.h);
            }
            ctx.fill();
        }
    }

    class Star {
        constructor(x, y) {
            this.x = x; this.y = y; this.w = 20; this.h = 20;
            this.collected = false;
            this.float = Math.random() * 10;
        }
        draw(ctx) {
            if(this.collected) return;
            this.float += 0.1;
            const fy = this.y + Math.sin(this.float) * 5;
            
            ctx.fillStyle = '#fbc02d';
            ctx.beginPath();
            const cx = this.x + 10; const cy = fy + 10;
            for(let i=0; i<5; i++){
                ctx.lineTo(Math.cos((18+i*72)/180*Math.PI)*10 + cx, 
                           -Math.sin((18+i*72)/180*Math.PI)*10 + cy);
                ctx.lineTo(Math.cos((54+i*72)/180*Math.PI)*5 + cx, 
                           -Math.sin((54+i*72)/180*Math.PI)*5 + cy);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#fff7d5';
            ctx.stroke();
        }
    }

    // ---------- GLOBAL STATE ----------
    let gameData = {
        level: 1,
        starsCollected: 0,
        platforms: [],
        traps: [],
        stars: [],
        goal: null
    };
    
    let player;
    let particles = [];
    let keys = { left: false, right: false, jumpHeld: false, jumpPressed: false };
    let gameState = 'menu'; // menu, playing, win

    // ---------- LEVEL GENERATION (PROCEDURAL) ----------
    function generateLevel(levelNum) {
        let platforms = [];
        let traps = [];
        let stars = [];
        
        // Difficulty parameters
        const gapSize = Math.min(180, 80 + levelNum * 3); 
        const platformMinW = Math.max(50, 150 - levelNum * 2);
        const movingChance = levelNum > 5 ? 0.3 : 0;
        const fallChance = levelNum > 3 ? 0.2 : 0;
        const spikeChance = levelNum > 2 ? Math.min(0.6, 0.1 + levelNum * 0.02) : 0;
        
        let cx = 50;
        let cy = 400;

        // Start Platform
        platforms.push(new Platform(cx, cy, 200, 30));
        cx += 200;

        // Generate chunks
        const length = 10 + Math.floor(levelNum * 0.5); // Level gets longer
        
        for(let i=0; i<length; i++) {
            // Calculate next position
            cx += 60 + Math.random() * (gapSize - 60);
            cy += (Math.random() - 0.5) * 150; 
            
            // Clamp Y
            if(cy < 150) cy = 150;
            if(cy > 500) cy = 500;

            const w = platformMinW + Math.random() * 80;
            
            let type = 'normal';
            if(Math.random() < movingChance) type = 'move';
            else if(Math.random() < fallChance) type = 'fall';

            platforms.push(new Platform(cx, cy, w, 30, type));

            // Add Spike on platform
            if (type === 'normal' && Math.random() < spikeChance) {
                traps.push(new Trap(cx + w/2 - 15, cy - 15, 30, 15));
            }
            
            // Add Stars (Every 3rd platform approx)
            if (i % 3 === 0) {
                stars.push(new Star(cx + w/2 - 10, cy - 50));
            }

            cx += w;
        }

        // Final Platform & Goal
        cx += 100;
        cy = 400;
        platforms.push(new Platform(cx, cy, 200, 30));
        
        // Ensure at least 3 stars spawned, else add them at end
        while(stars.length < 3) {
            stars.push(new Star(cx + 20 + stars.length * 40, cy - 50));
        }

        const goal = { x: cx + 150, y: cy - 60, w: 40, h: 60 };
        
        return { platforms, traps, stars, goal };
    }

    // ---------- HELPER FUNCTIONS ----------
    function lerp(a, b, t) { return a + (b - a) * t; }
    
    function spawnParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                size: Math.random() * 5 + 2,
                color: color,
                life: 30
            });
        }
    }
    
    function spawnExplosion(x, y) { spawnParticles(x, y, '#ff5252', 20); }

    // ---------- CORE FUNCTIONS ----------
    function showMenu() {
        gameState = 'menu';
        menuOverlay.style.display = 'flex';
        winOverlay.style.display = 'none';
        levelSpan.innerText = '1';
    }

    function startGame() {
        gameData.level = 1;
        startLevel(1);
    }

    function startLevel(lvl) {
        gameState = 'playing';
        menuOverlay.style.display = 'none';
        winOverlay.style.display = 'none';
        
        // Transition Animation
        transitionOverlay.style.display = 'flex';
        levelTitle.innerText = "LEVEL " + lvl;
        setTimeout(() => { transitionOverlay.style.opacity = 0; }, 800);
        setTimeout(() => { 
            transitionOverlay.style.display = 'none'; 
            transitionOverlay.style.opacity = 1;
        }, 1100);

        // Generate Level Data
        const data = generateLevel(lvl);
        gameData.platforms = data.platforms;
        gameData.traps = data.traps;
        gameData.stars = data.stars;
        gameData.goal = data.goal;
        gameData.starsCollected = 0;
        
        // Spawn Player
        player = new Player(50, 300); // Drop in
        
        // UI Update
        levelSpan.innerText = lvl;
        starSpan.innerText = "0/3";
    }

    function nextLevel() {
        sound.play('win');
        if (gameData.level >= TOTAL_LEVELS) {
            gameState = 'win';
            winOverlay.style.display = 'flex';
        } else {
            gameData.level++;
            startLevel(gameData.level);
        }
    }

    function resetLevel() {
        startLevel(gameData.level);
    }

    // ---------- MAIN LOOP ----------
    function update() {
        if (gameState !== 'playing') return;

        player.update(gameData.platforms, gameData.traps, gameData.stars, gameData.goal);
        gameData.platforms.forEach(p => p.update());

        // Particles
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.size *= 0.92;
            p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        }
        
        // Camera Follow (Horizontal only)
        // Keep player in middle 1/3 of screen
        // In a real engine we'd translate the context, here we move entities for simplicity relative to view?
        // Actually, let's do context translation in Draw for better performance.
    }

    function draw() {
        ctx.fillStyle = '#e1f5fe';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (gameState === 'playing') {
            
            // Camera Logic
            let camX = 0;
            // Center player horizontally with clamping
            if(player.x > 400) {
                camX = 400 - player.x;
            }
            
            ctx.save();
            ctx.translate(camX, 0);

            // Draw Parallax clouds (Simple)
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.beginPath();
            ctx.arc(100 - camX*0.2, 100, 60, 0, Math.PI*2);
            ctx.arc(800 - camX*0.2, 150, 80, 0, Math.PI*2);
            ctx.fill();

            // Draw World
            gameData.platforms.forEach(p => p.draw(ctx));
            gameData.traps.forEach(t => t.draw(ctx));
            gameData.stars.forEach(s => s.draw(ctx));

            // Goal
            if (gameData.goal) {
                const g = gameData.goal;
                
                // Door Frame
                ctx.fillStyle = '#5d4037';
                ctx.fillRect(g.x, g.y, g.w, g.h);
                
                // Door Interior
                ctx.fillStyle = gameData.starsCollected >= 3 ? '#a7ffeb' : '#3e2723';
                ctx.fillRect(g.x + 5, g.y + 5, g.w - 10, g.h - 5);
                
                // Sign
                if(gameData.starsCollected < 3) {
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.fillText(gameData.starsCollected + "/3", g.x + 10, g.y - 10);
                } else {
                    ctx.fillStyle = 'yellow';
                    ctx.fillText("GO!", g.x + 10, g.y - 10);
                }
            }

            player.draw(ctx);

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            });

            ctx.restore();
        }

        requestAnimationFrame(() => { update(); draw(); });
    }

    // ---------- INPUT HANDLING ----------
    window.addEventListener('keydown', e => {
        if(e.code === 'ArrowLeft') keys.left = true;
        if(e.code === 'ArrowRight') keys.right = true;
        if(e.code === 'Space' || e.code === 'ArrowUp') {
            if(!keys.jumpHeld) keys.jumpPressed = true;
            keys.jumpHeld = true;
        }
    });

    window.addEventListener('keyup', e => {
        if(e.code === 'ArrowLeft') keys.left = false;
        if(e.code === 'ArrowRight') keys.right = false;
        if(e.code === 'Space' || e.code === 'ArrowUp') keys.jumpHeld = false;
    });

    // Start
    draw();

})();
</script>
</body>
</html>
